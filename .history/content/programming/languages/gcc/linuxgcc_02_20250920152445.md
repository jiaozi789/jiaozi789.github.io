---
title: "linux下gcc编程02-gdb调试工具使用"
date: 2025-09-18T16:55:17+08:00
# bookComments: false
# bookSearchExclude: false
---

**一。gdb调试工具简介**

  GDB（GNU Debugger）是GCC的调试工具。其功能强大，现描述如下： 

GDB主要帮忙你完成下面四个方面的功能： 

1.启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。 

2.可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式） 

3.当程序被停住时，可以检查此时你的程序中所发生的事。 

4.动态的改变你程序的执行环境。

gdb调试工具使用必须在应用程序编译时生成调试信息 gcc添加 -g参数

```
[root@cdh2 vc]# gcc -g hello.c -o hello
```

gcc常用命令列表

 回车键：重复上一命令

help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h

run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r

start：单步执行，运行程序，停在第一执行语句

list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l

set：设置变量的值

next：单步调试（逐过程，函数直接执行）,简写n

step：单步调试（逐语句：跳入自定义函数内部执行）,简写s

backtrace：查看函数的调用的栈帧和层级关系,简写bt

frame：切换函数的栈帧,简写f

info：查看函数内部局部变量的数值,简写i

finish：结束当前函数，返回到函数调用点

continue：继续运行,简写c

print：打印值及地址,简写p

quit：退出gdb,简写q

break num：在第num行设置断点,简写b

  其他语法参考

```
break 10    某行下断点
break test.c:10 某个文件某行下断点
break main  某个方法上下断点
break test.c:main 某个文件某个方法
 
如果想在指定的地址设置断点，比如在main函数的地址出设断点。
可用info add main 获得main的地址如0x80484624，然后用break *0x80484624.
条件断点就是在如上述指定断点的同时指定进入断点的条件。
例如：（假如有int 类型变量 index）
break 10 if index == 3
```

info breakpoints：查看当前设置的所有断点

delete breakpoints num：删除第num个断点,简写d

display：追踪查看具体变量值

undisplay：取消追踪观察变量

watch：被设置观察点的变量发生修改时，打印显示

i watch：显示观察点

enable breakpoints：启用断点

disable breakpoints：禁用断点

x：查看内存x/20xw 显示20个单元，16进制，4字节每单元

run argv[1] argv[2]：调试时命令行传参

set follow-fork-mode child#Makefile项目管理：选择跟踪父子进程（fork()）

core文件：先用$ ulimit -c 1024 开启core，当程序出错会自动生成core文件。调试时 gdb a.out core

**二。gdb调试小案例**

添加文件编写以下代码

```
#include <stdio.h>
 
int add(int i,int j){
	int result=i+j;
	return result;
}
void main(){
	printf("helloworld\n");
	int k=add(10,100);
	printf("%d",k);
}
```

带调试信息编译

```
[root@cdh2 vc]# gcc -g hello1.c hello1AI写代码
```

打开文件

```
gdb hello1 自动进入gdb命令行AI写代码
```

main方法和第9行下断点

```
b mainb 9AI写代码
```

查看所有断点

```
(gdb) info bNum     Type           Disp Enb Address            What1       breakpoint     keep y   0x00000000004005a2 in main at hello1.c:92       breakpoint     keep y   0x00000000004005a2 in main at hello1.c:9AI写代码
```

开始运行run 发现在main方法上自动断下了 并且下一行执行第9行

```
(gdb) runStarting program: /root/vc/hello1  Breakpoint 1, main () at hello1.c:99               printf("helloworld\n");Missing separate debuginfos, use: debuginfo-install glibc-2.17-157.el7_3.5.x86_64AI写代码
```

next表示下一步运行 存在子方法直接跳过 输出了第9行的helloworld 下一次next执行第10行

```
nhelloworld10              int k=add(10,100);AI写代码
```

step表示下一步运行 存在子方法自动进入子方法

```
(gdb) sadd (i=10, j=100) at hello1.c:5  下一步执行add第5行5               int result=i+j;(gdb) s   执行 result应该有结果了6               return result;(gdb) print result  print打印result的值$2 = 110AI写代码
```

输入finish 完成子函数的调用回到父函数main中

```
(gdb) finishRun till exit from #0  add (i=10, j=100) at hello1.c:60x00000000004005bb in main () at hello1.c:1010              int k=add(10,100);Value returned is $3 = 110AI写代码
```

输入 continue 执行 如果后面还有断点 段下来 没有直接运行结束了

 

```
(gdb) cContinuing.110[Inferior 1 (process 7134) exited with code 03]
```
<!DOCTYPE html>
<html lang="zh" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.150.0">
    <meta name="generator" content="Relearn 8.0.1+b23cf6629eada0c2802f34ae4012e04343497862">
    <meta name="description" content="简介 68000 汇编语言是为 Motorola 68000 微处理器设计的低级编程语言。68000 微处理器于 1979 年推出，因其强大的性能和灵活的架构而广泛应用于多种计算机系统和嵌入式设备中。以下是对 68000 汇编语言的背景、应用领域以及学习它的好处的详细介绍。
产生背景 技术进步：
68000 微处理器是 16 位架构，具有 32 位的地址总线，能够寻址高达 4GB 的内存。这使得它在当时的微处理器中具有较高的性能和灵活性。 其设计采用了复杂指令集计算（CISC）架构，支持多种寻址模式和丰富的指令集。 市场需求：
1970 年代末和1980年代初，个人计算机和嵌入式系统的需求迅速增长。68000 微处理器因其性能和成本效益被广泛采用。 许多知名的计算机系统（如 Apple Macintosh、Atari ST 和 Sega Genesis）都使用了 68000 处理器。 应用领域 个人计算机：
68000 微处理器被用于早期的个人计算机，如 Apple Macintosh 和 Atari ST。这些系统的操作系统和应用程序通常使用 68000 汇编语言进行开发。 嵌入式系统：
68000 处理器也被广泛应用于嵌入式系统，如工业控制、汽车电子和消费电子产品。 游戏机：
Sega Genesis 和其他游戏机使用 68000 处理器，许多经典游戏都是用 68000 汇编语言编写的，学习后可以做一些hackrom的实战。 实时系统：
由于其高效的性能，68000 处理器在实时系统中也得到了应用，如医疗设备和航空航天系统。 语言学习 EASy68K EASy68K 是一个 68000 结构化汇编语言集成开发环境（IDE）。EASy68K 允许您在 Windows PC 或 Wine 上编辑、汇编和运行 68000 程序。无需额外的硬件。EASy68K 是一个开源项目，根据 GNU 通用公共使用许可分发。 使用easy68k方便我们学习整套68000的编程和调试，学习这件基础知识，对我们hackrom或者逆向的基础。 下载地址：http://www.easy68k.com/files/SetupEASy68K.exe 安装完成后的目录结构">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="68000汇编实战01-编程基础 :: liaomin416100569博客">
    <meta name="twitter:description" content="简介 68000 汇编语言是为 Motorola 68000 微处理器设计的低级编程语言。68000 微处理器于 1979 年推出，因其强大的性能和灵活的架构而广泛应用于多种计算机系统和嵌入式设备中。以下是对 68000 汇编语言的背景、应用领域以及学习它的好处的详细介绍。
产生背景 技术进步：
68000 微处理器是 16 位架构，具有 32 位的地址总线，能够寻址高达 4GB 的内存。这使得它在当时的微处理器中具有较高的性能和灵活性。 其设计采用了复杂指令集计算（CISC）架构，支持多种寻址模式和丰富的指令集。 市场需求：
1970 年代末和1980年代初，个人计算机和嵌入式系统的需求迅速增长。68000 微处理器因其性能和成本效益被广泛采用。 许多知名的计算机系统（如 Apple Macintosh、Atari ST 和 Sega Genesis）都使用了 68000 处理器。 应用领域 个人计算机：
68000 微处理器被用于早期的个人计算机，如 Apple Macintosh 和 Atari ST。这些系统的操作系统和应用程序通常使用 68000 汇编语言进行开发。 嵌入式系统：
68000 处理器也被广泛应用于嵌入式系统，如工业控制、汽车电子和消费电子产品。 游戏机：
Sega Genesis 和其他游戏机使用 68000 处理器，许多经典游戏都是用 68000 汇编语言编写的，学习后可以做一些hackrom的实战。 实时系统：
由于其高效的性能，68000 处理器在实时系统中也得到了应用，如医疗设备和航空航天系统。 语言学习 EASy68K EASy68K 是一个 68000 结构化汇编语言集成开发环境（IDE）。EASy68K 允许您在 Windows PC 或 Wine 上编辑、汇编和运行 68000 程序。无需额外的硬件。EASy68K 是一个开源项目，根据 GNU 通用公共使用许可分发。 使用easy68k方便我们学习整套68000的编程和调试，学习这件基础知识，对我们hackrom或者逆向的基础。 下载地址：http://www.easy68k.com/files/SetupEASy68K.exe 安装完成后的目录结构">
    <meta property="og:url" content="https://jiaozi789.github.io/docs/programming/languages/assembly/68000_01_base/index.html">
    <meta property="og:site_name" content="liaomin416100569博客">
    <meta property="og:title" content="68000汇编实战01-编程基础 :: liaomin416100569博客">
    <meta property="og:description" content="简介 68000 汇编语言是为 Motorola 68000 微处理器设计的低级编程语言。68000 微处理器于 1979 年推出，因其强大的性能和灵活的架构而广泛应用于多种计算机系统和嵌入式设备中。以下是对 68000 汇编语言的背景、应用领域以及学习它的好处的详细介绍。
产生背景 技术进步：
68000 微处理器是 16 位架构，具有 32 位的地址总线，能够寻址高达 4GB 的内存。这使得它在当时的微处理器中具有较高的性能和灵活性。 其设计采用了复杂指令集计算（CISC）架构，支持多种寻址模式和丰富的指令集。 市场需求：
1970 年代末和1980年代初，个人计算机和嵌入式系统的需求迅速增长。68000 微处理器因其性能和成本效益被广泛采用。 许多知名的计算机系统（如 Apple Macintosh、Atari ST 和 Sega Genesis）都使用了 68000 处理器。 应用领域 个人计算机：
68000 微处理器被用于早期的个人计算机，如 Apple Macintosh 和 Atari ST。这些系统的操作系统和应用程序通常使用 68000 汇编语言进行开发。 嵌入式系统：
68000 处理器也被广泛应用于嵌入式系统，如工业控制、汽车电子和消费电子产品。 游戏机：
Sega Genesis 和其他游戏机使用 68000 处理器，许多经典游戏都是用 68000 汇编语言编写的，学习后可以做一些hackrom的实战。 实时系统：
由于其高效的性能，68000 处理器在实时系统中也得到了应用，如医疗设备和航空航天系统。 语言学习 EASy68K EASy68K 是一个 68000 结构化汇编语言集成开发环境（IDE）。EASy68K 允许您在 Windows PC 或 Wine 上编辑、汇编和运行 68000 程序。无需额外的硬件。EASy68K 是一个开源项目，根据 GNU 通用公共使用许可分发。 使用easy68k方便我们学习整套68000的编程和调试，学习这件基础知识，对我们hackrom或者逆向的基础。 下载地址：http://www.easy68k.com/files/SetupEASy68K.exe 安装完成后的目录结构">
    <meta property="og:locale" content="zh">
    <meta property="og:type" content="article">
    <meta property="article:section" content="编程开发">
    <meta property="article:published_time" content="2025-09-18T16:55:17+08:00">
    <meta property="article:modified_time" content="2025-09-18T16:55:17+08:00">
    <meta itemprop="name" content="68000汇编实战01-编程基础 :: liaomin416100569博客">
    <meta itemprop="description" content="简介 68000 汇编语言是为 Motorola 68000 微处理器设计的低级编程语言。68000 微处理器于 1979 年推出，因其强大的性能和灵活的架构而广泛应用于多种计算机系统和嵌入式设备中。以下是对 68000 汇编语言的背景、应用领域以及学习它的好处的详细介绍。
产生背景 技术进步：
68000 微处理器是 16 位架构，具有 32 位的地址总线，能够寻址高达 4GB 的内存。这使得它在当时的微处理器中具有较高的性能和灵活性。 其设计采用了复杂指令集计算（CISC）架构，支持多种寻址模式和丰富的指令集。 市场需求：
1970 年代末和1980年代初，个人计算机和嵌入式系统的需求迅速增长。68000 微处理器因其性能和成本效益被广泛采用。 许多知名的计算机系统（如 Apple Macintosh、Atari ST 和 Sega Genesis）都使用了 68000 处理器。 应用领域 个人计算机：
68000 微处理器被用于早期的个人计算机，如 Apple Macintosh 和 Atari ST。这些系统的操作系统和应用程序通常使用 68000 汇编语言进行开发。 嵌入式系统：
68000 处理器也被广泛应用于嵌入式系统，如工业控制、汽车电子和消费电子产品。 游戏机：
Sega Genesis 和其他游戏机使用 68000 处理器，许多经典游戏都是用 68000 汇编语言编写的，学习后可以做一些hackrom的实战。 实时系统：
由于其高效的性能，68000 处理器在实时系统中也得到了应用，如医疗设备和航空航天系统。 语言学习 EASy68K EASy68K 是一个 68000 结构化汇编语言集成开发环境（IDE）。EASy68K 允许您在 Windows PC 或 Wine 上编辑、汇编和运行 68000 程序。无需额外的硬件。EASy68K 是一个开源项目，根据 GNU 通用公共使用许可分发。 使用easy68k方便我们学习整套68000的编程和调试，学习这件基础知识，对我们hackrom或者逆向的基础。 下载地址：http://www.easy68k.com/files/SetupEASy68K.exe 安装完成后的目录结构">
    <meta itemprop="datePublished" content="2025-09-18T16:55:17+08:00">
    <meta itemprop="dateModified" content="2025-09-18T16:55:17+08:00">
    <meta itemprop="wordCount" content="1873">
    <title>68000汇编实战01-编程基础 :: liaomin416100569博客</title>
    <link href="/docs/css/auto-complete/auto-complete.min.css?1758355652" rel="stylesheet">
    <script src="/docs/js/auto-complete/auto-complete.min.js?1758355652" defer></script>
    <script src="/docs/js/search-lunr.min.js?1758355652" defer></script>
    <script src="/docs/js/search.min.js?1758355652" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/docs/searchindex.en.js?1758355652";
    </script>
    <script src="/docs/js/lunr/lunr.min.js?1758355652" defer></script>
    <script src="/docs/js/lunr/lunr.stemmer.support.min.js?1758355652" defer></script>
    <script src="/docs/js/lunr/lunr.multi.min.js?1758355652" defer></script>
    <script src="/docs/js/lunr/lunr.zh.min.js?1758355652" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['zh'];
    </script>
    <link href="/docs/fonts/fontawesome/css/fontawesome-all.min.css?1758355652" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/docs/fonts/fontawesome/css/fontawesome-all.min.css?1758355652" rel="stylesheet"></noscript>
    <link href="/docs/css/perfect-scrollbar/perfect-scrollbar.min.css?1758355652" rel="stylesheet">
    <link href="/docs/css/theme.min.css?1758355652" rel="stylesheet">
    <link href="/docs/css/format-html.min.css?1758355652" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/programming\/languages\/assembly\/68000_01_base\/index.html';
      window.relearn.relBasePath='..\/..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..\/..\/..';
      window.relearn.absBaseUri='https:\/\/jiaozi789.github.io\/docs';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=false;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'auto' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/docs/css/custom.css?1758355652" rel="stylesheet">
  </head>
  <body class="mobile-support html" data-url="/docs/programming/languages/assembly/68000_01_base/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a>
      <ul>
        <li><a href="#产生背景">产生背景</a></li>
        <li><a href="#应用领域">应用领域</a></li>
      </ul>
    </li>
    <li><a href="#语言学习">语言学习</a>
      <ul>
        <li><a href="#easy68k">EASy68K</a>
          <ul>
            <li><a href="#帮助文档">帮助文档</a></li>
            <li><a href="#ide使用">IDE使用</a></li>
          </ul>
        </li>
        <li><a href="#编程语言">编程语言</a>
          <ul>
            <li><a href="#comments">comments</a></li>
            <li><a href="#operands-操作数">operands 操作数</a>
              <ul>
                <li><a href="#区别">#,$,%区别</a></li>
                <li><a href="#操作数移动">操作数移动</a></li>
              </ul>
            </li>
            <li><a href="#labels">labels</a>
              <ul>
                <li><a href="#开始标签">开始标签</a></li>
                <li><a href="#指令标签">指令标签</a></li>
                <li><a href="#位置标签">位置标签</a></li>
              </ul>
            </li>
            <li><a href="#opcode-操作码">opcode 操作码</a>
              <ul>
                <li><a href="#常用操作码">常用操作码</a></li>
                <li><a href="#io操作码">IO操作码</a></li>
                <li><a href="#其他操作码">其他操作码</a></li>
              </ul>
            </li>
            <li><a href="#directives-指令">directives 指令</a>
              <ul>
                <li><a href="#dc指令">DC指令</a></li>
                <li><a href="#equ-指令">EQU 指令</a></li>
                <li><a href="#set-指令">SET 指令</a></li>
                <li><a href="#ds-指令">DS 指令</a></li>
                <li><a href="#其他指令">其他指令</a></li>
              </ul>
            </li>
            <li><a href="#寄存器">寄存器</a>
              <ul>
                <li><a href="#程序计数器pc">程序计数器（PC）</a></li>
                <li><a href="#状态寄存器sr">状态寄存器（SR）</a></li>
                <li><a href="#数据寄存器d">数据寄存器（D)</a></li>
                <li><a href="#地址寄存器a">地址寄存器（A)</a></li>
                <li><a href="#堆栈寄存器ss">堆栈寄存器（SS)</a></li>
              </ul>
            </li>
            <li><a href="#案例99乘法表">案例(9*9乘法表)</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/docs/index.html"><span itemprop="name">liaomin416100569博客</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/docs/programming/index.html"><span itemprop="name">编程开发</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/docs/programming/languages/index.html"><span itemprop="name">编程语言</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/docs/programming/languages/assembly/index.html"><span itemprop="name">汇编语言</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">68000汇编实战01-编程基础</span><meta itemprop="position" content="5"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/docs/programming/languages/assembly/index.html" title="汇编语言 (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/docs/programming/ai/index.html" title="人工智能 (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable programming" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="68000汇编实战01-编程基础">68000汇编实战01-编程基础</h1>

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']]
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

<h1 id="简介">简介</h1>
<p>68000 汇编语言是为 Motorola 68000 微处理器设计的低级编程语言。68000 微处理器于 1979 年推出，因其强大的性能和灵活的架构而广泛应用于多种计算机系统和嵌入式设备中。以下是对 68000 汇编语言的背景、应用领域以及学习它的好处的详细介绍。</p>
<h2 id="产生背景">产生背景</h2>
<ol>
<li>
<p><strong>技术进步</strong>：</p>
<ul>
<li>68000 微处理器是 16 位架构，具有 32 位的地址总线，能够寻址高达 4GB 的内存。这使得它在当时的微处理器中具有较高的性能和灵活性。</li>
<li>其设计采用了复杂指令集计算（CISC）架构，支持多种寻址模式和丰富的指令集。</li>
</ul>
</li>
<li>
<p><strong>市场需求</strong>：</p>
<ul>
<li>1970 年代末和1980年代初，个人计算机和嵌入式系统的需求迅速增长。68000 微处理器因其性能和成本效益被广泛采用。</li>
<li>许多知名的计算机系统（如 Apple Macintosh、Atari ST 和 Sega Genesis）都使用了 68000 处理器。</li>
</ul>
</li>
</ol>
<h2 id="应用领域">应用领域</h2>
<ol>
<li>
<p><strong>个人计算机</strong>：</p>
<ul>
<li>68000 微处理器被用于早期的个人计算机，如 Apple Macintosh 和 Atari ST。这些系统的操作系统和应用程序通常使用 68000 汇编语言进行开发。</li>
</ul>
</li>
<li>
<p><strong>嵌入式系统</strong>：</p>
<ul>
<li>68000 处理器也被广泛应用于嵌入式系统，如工业控制、汽车电子和消费电子产品。</li>
</ul>
</li>
<li>
<p><strong>游戏机</strong>：</p>
<ul>
<li>Sega Genesis 和其他游戏机使用 68000 处理器，许多经典游戏都是用 68000 汇编语言编写的，学习后可以做一些hackrom的实战。</li>
</ul>
</li>
<li>
<p><strong>实时系统</strong>：</p>
<ul>
<li>由于其高效的性能，68000 处理器在实时系统中也得到了应用，如医疗设备和航空航天系统。</li>
</ul>
</li>
</ol>
<h1 id="语言学习">语言学习</h1>
<h2 id="easy68k">EASy68K</h2>
<p>EASy68K 是一个 68000 结构化汇编语言集成开发环境（IDE）。EASy68K 允许您在 Windows PC 或 Wine 上编辑、汇编和运行 68000 程序。无需额外的硬件。EASy68K 是一个开源项目，根据 GNU 通用公共使用许可分发。
使用easy68k方便我们学习整套68000的编程和调试，学习这件基础知识，对我们hackrom或者逆向的基础。
下载地址：http://www.easy68k.com/files/SetupEASy68K.exe
安装完成后的目录结构
<a href="#R-image-20b40a557c59f0faa0180363fec94d89" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/6c97aae7b6c14158adc239b138d0938a.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-20b40a557c59f0faa0180363fec94d89"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/6c97aae7b6c14158adc239b138d0938a.png"></a></p>
<h3 id="帮助文档">帮助文档</h3>
<p>helm.chm提供了完整的编程和调试工具以及68k语言的学习入门资料，可以直接从该文档入手。
<a href="#R-image-70f69d0e96032a2b9db6ae9fc2fdf8a7" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/0fc37f3c1b1a49b8bad469f8b179b902.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-70f69d0e96032a2b9db6ae9fc2fdf8a7"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/0fc37f3c1b1a49b8bad469f8b179b902.png"></a></p>
<h3 id="ide使用">IDE使用</h3>
<p>打开EDIT68K.exe，菜单file-&gt;new x68 source file 。
在source里面实现一个功能，打印helloworld，并从空值台输入一个字符串并打印。</p>
<blockquote>
<p>关于指令，标签，寄存器其他相关的内容请移步后续章节。</p></blockquote>
<p>源代码</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>*-----------------------------------------------------------
* Title      :
* Written by :
* Date       :
* Description:
*-----------------------------------------------------------
    ORG    $1000 ;告诉编译器代码从1000位置开始，不指定默认从0开始
START:                  ; first instruction of program
    * 将text字符串地址写给A1
    lea text,A1
    * 将14号task print 给d0,并执行，14号任务自动获取A1地址的数据并打印
    move #14,D0
    trap #15
    * 执行2号任务，从输入流获取输入，自动写入到A1
    move #2,D0
    trap #15
    * 打印A1地址内容
    move #14,D0
    trap #15

    
* Put program code here
*-----------------------------------------------------------
*HELLO：这是一个标签，标识字符串数据的起始位置。
*DC.B：这是一个伪指令，表示“定义常量（Define Constant）”，后面的 .B 表示定义的是字节（Byte）数据。
*&#39;Hello World&#39;：这是一个字符串常量，表示字符数组。每个字符占用一个字节。
*$D：这是一个十六进制常量，表示一个字节的值。$D 的十进制值是 13，通常表示回车符（Carriage Return）。
*$A：这是一个十六进制常量，表示一个字节的值。$A 的十进制值是 10，通常表示换行符（Line Feed）。
*0：这是一个字节的值，表示字符串的结束符（null terminator），在 C 语言中常用来标识字符串的结束。
*-----------------------------------------------------------    
text dc.b  &#39;helloworld&#39;,0
    SIMHALT             ; halt simulator

* Put variables and constants here

    END    START        ; last line of source</code></pre></div>
<p>点击工具栏运行按钮（如果由错误会有提示，根据情况修正）
<a href="#R-image-9d038b7dab62fe9c3065e1aa0b9622fa" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/9b7eb5d323354da5ad374420eeae62cc.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9d038b7dab62fe9c3065e1aa0b9622fa"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/9b7eb5d323354da5ad374420eeae62cc.png"></a>
会弹出一个确认框
<a href="#R-image-bc95d4b5b6f64cade9b02a32cfb51355" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/71c97cddf75e47339ba1486a05d35704.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bc95d4b5b6f64cade9b02a32cfb51355"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/71c97cddf75e47339ba1486a05d35704.png"></a>
点击execute
<a href="#R-image-408606a7bbfb861cc1cc533578be60b0" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/0ef99984088a4be88c691ff448dc0449.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-408606a7bbfb861cc1cc533578be60b0"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/0ef99984088a4be88c691ff448dc0449.png"></a>
绿色圈圈点击变成红色可下断点，F9运行，F8 stepover,F7 stepinto,点击运行可调试。
<a href="#R-image-94f6239eac5ff81b3f43629c55c3a18b" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/a8eed5a2d7af41929a1e6cef9f8c21b3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-94f6239eac5ff81b3f43629c55c3a18b"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/a8eed5a2d7af41929a1e6cef9f8c21b3.png"></a></p>
<p>在view可打开内存窗口，栈窗口等
<a href="#R-image-22bc95e976b1a806fed3e9c209695f7a" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/a5c2c3048b0d4719bd956c4982471508.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-22bc95e976b1a806fed3e9c209695f7a"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/a5c2c3048b0d4719bd956c4982471508.png"></a></p>
<h2 id="编程语言">编程语言</h2>
<p>汇编语言程序由以下部分组成：</p>
<ul>
<li>labels 标签 - 用户创建的名称，用于标记程序中的位置。</li>
<li>opcode 操作码 - 微处理器可以执行的特定指令，比如ADD，MOVE等。</li>
<li>operands 操作数 - 某些指令所需的附加数据，比如#1表示10进制立即数1，$1表示16进制的1。</li>
<li>directives 指令 - 发给汇编器的命令，比如ORG    $1000，告诉编译器，代码的开始位置，代码段不占用空间，类似于c语言的宏，编译阶段使用。</li>
<li>macros 宏 - 用户创建的源代码集合，可以在编写程序时轻松重用。</li>
<li>comments 注释 - 用户创建的文本字符串，用于记录程序。</li>
<li>寄存器：汇编语言编程需要与微处理器进行直接交互。68000 微处理器包含八个数据寄存器 D0 到 D7。数据寄存器是通用的，可以视为 8 位、16 位或 32 位的整数变量。还有八个地址寄存器 A0 到 A7，地址寄存器的长度为 32 位。它们通常用于引用变量。状态寄存器（SR）包含状态标志，用于指示比较的结果。</li>
</ul>
<p>以下是一个例子
<a href="#R-image-55c90270105903c7e555ad89fdea72d1" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/67aec030665244dea785e7a8fa2e8ded.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-55c90270105903c7e555ad89fdea72d1"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/67aec030665244dea785e7a8fa2e8ded.png"></a></p>
<h3 id="comments">comments</h3>
<p>在 Motorola 68000（68k）汇编语言中，注释用于帮助程序员理解代码的功能和逻辑。68k 汇编语言的注释格式如下：（*或者;开头的为注释）</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>* Date    
TRAP #15  ;将3任务执行，自动打印D1的内容</code></pre></div>
<h3 id="operands-操作数">operands 操作数</h3>
<h4 id="区别">#,$,%区别</h4>
<p>你可能也注意到了出现在32和0000001E前面的#和$符号，$符号是为了告诉汇编器这个数字是“十六进制”数字(是个地址)，而不是“十进制”数字，例如：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>          move.b    #32,$0000001E</code></pre></div>
<p>汇编器在进行汇编时会将32（十进制）转换为0010 0000（二进制）。0010 0000 是 20 十六进制，因此写 32 和写 $20 是一样的，0010 0000将写入地址0000001E。如果你想要写二进制数，可以使用 % 符号。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>		  move.b    #%00100000,$0000001E
          move.b    #$20,$0000001E
          move.b    #32,$0000001E</code></pre></div>
<p>以上所有内容完全相同，顶部是二进制版本（%），中间是十六进制（$），底部是十进制。在本教程中，我们将更多地使用十六进制和二进制，而不是十进制，以帮助你更好地理解和掌握它们。</p>
<p>另一方面，# 符号告诉汇编器，该数字是一个“立即”值，而不是一个偏移量。那么什么是“立即”值呢？稍安勿躁，让我们先看一个没有 # 符号的例子：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>move.b    $00000010,$0000002D</code></pre></div>
<p>这将读取偏移量00000010处的字节，并将其复制到偏移量0000002D处，如果偏移量00000010处的字节是49，则0000002D处现在也将是49：
<a href="#R-image-03957902fc7a81bd9fa4e0a5afb12d09" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/942c218d66a74944bb7f11dafd2c9dbf.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-03957902fc7a81bd9fa4e0a5afb12d09"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/942c218d66a74944bb7f11dafd2c9dbf.png"></a>
而现在回到“立即数”，在我看来，这只不过是“直接数字”的一个花哨名称，#符号告诉68k这个数字不是偏移量/地址。</p>
<h4 id="操作数移动">操作数移动</h4>
<p>给个例子</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>    move.w #$10,$0020  ;将立即数16进制10 写入内存地址$0020
    move $0020,D0         ;将内存地址$0020的值10赋值给D0
    move $0020,A0         ;将将内存地址$0020的值10赋值给地址寄存器A0
    move #$0020,A1       ;将立即数$0020赋值给地址寄存器A1
    move A1,D1               ;将A1地址#$0020赋予给D1
    move (A1),D2            ;将A1地址#$0020内存的值10赋予给D2

    move.w    (a0),(a1)      ;将a0地址的值赋给a1地址的内存
    move.w    d1,(a0)+      ;将d1的数据，写入a0+word(2个字节)，并且a0寄存器往后移动两位，比如a0=0000,执行完a0=0002
    move.w    d1,$10(a1) ;将d1数据写入a1+10个字节的位置，a1的指向不变，比如a1=0000，写入数据到0010，执行完a1=0000
    move.b    #$98,(a0)+    ;同上上，写入立即数
    move.l    $29(a0),$00120020 ;将a0+29位置的值写入$00120020位置
    move.b    $00120020,(a1)+</code></pre></div>
<blockquote>
<p>注意：move.w    $00000047,d0 这个会导致汇编程序崩溃，因为00000047是一个奇数（奇地址/偏移量），68k在处理时会有问题，并会因“地址错误”而崩溃，字w和双字l必须使用偶数地址，如果要使用奇数地址请使用字节b。</p></blockquote>
<p>你只能使用“字节”来访问奇地址上的数据：</p>
<h3 id="labels">labels</h3>
<p>标签用于通过名称标识程序中的位置或内存位置。需要位置的指令或指令可以使用标签来指示该位置。标签通常在行的第一列开始，必须以空格、制表符或冒号结束。如果使用冒号，它不会成为标签的一部分。如果标签没有在第一列开始，则必须以冒号结束。标签的前 32 个字符是有效的。标签有两种类型：全局标签和局部标签。</p>
<p>全局标签可以在程序的任何地方被引用。因此，全局标签必须是唯一的名称。全局标签应以字母开头，后面可以跟字母、数字或下划线。局部标签可以在程序中重复使用。局部标签必须以点 &lsquo;.&rsquo; 开头，后面可以跟字母、数字或下划线。全局标签定义了局部标签的边界。当定义局部标签时，只有在遇到下一个全局标签之前，才能从局部标签上方或下方的代码中引用它。汇编器通过将局部标签名称附加到前面的全局标签并用冒号 &lsquo;:&rsquo; 替换点来创建局部标签的唯一名称。结果名称的前 32 个字符是有效的。</p>
<h4 id="开始标签">开始标签</h4>
<p>标签可以用来指定程序的起始位置。如果标签 START 指定了程序的起始位置，那么 END 指令的写法如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>START:                    Start of program
       code
       END    START</code></pre></div>
<h4 id="指令标签">指令标签</h4>
<p>标签常常放在某个指令前用来表示，定义变量，标签指向存储数据的首地址。
DC - DC 指令指示汇编器将后续的值放入当前内存位置。该指令有三种形式：DC.B 用于字节数据，DC.W 用于字（16 位）数据，DC.L 用于长（32 位）数据。定义常量指令不应与 C++ 中声明常量混淆。
例如</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>       ORG    $1000              start of the data region 
depart DC.B   &#39;depart.wav&#39;,0     stores as a NULL terminated string in consecutive bytes 
       DC.L   $01234567          the value $01234567 is stored as a long word
       DC.W   1,2                two words are stored as $0001 and $0002
       DC.L   1,2                two long words are stored as $00000001 and $00000002 </code></pre></div>
<blockquote>
<p>depart 就是一个label是这块内存区域的首地址。</p></blockquote>
<p>内存结果</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>00001000  64 65 70 61 72 74 2E 77 61 76 00 
0000100C  01234567 
00001010  0001 0002 
00001014  00000001 00000002</code></pre></div>
<p>其他关于指令标签的用法参考，也可以到指令章节：
<a href="#R-image-5bc93479eca50891b4bd325541ab4eae" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/25eb60d7cf9e4b79abe10fcabf8ac789.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5bc93479eca50891b4bd325541ab4eae"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/25eb60d7cf9e4b79abe10fcabf8ac789.png"></a></p>
<h4 id="位置标签">位置标签</h4>
<p>可以定义一些位置标签，当进行特殊操作时，可以通过控制流opcode跳转到位置标签
实现一个从0，end_index的循环打印</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>    ORG    $1000
START:                  ; first instruction of program

* Put program code here
* 实现一个从0，end_index的循环打印
    move #1,D1
t:
    move #3,D0
    TRAP #15  ;将3任务执行，自动打印D1的内容
    add.b #1,d1  ;让d1+1
    CMP #end_index,d1 ;比较d1和end_index的值
    BNE t  ;如果不相等继续跳转到t label执行
    SIMHALT             ; halt simulator

* Put variables and constants here
end_index equ 10
    END    START        ; last line of source</code></pre></div>
<h3 id="opcode-操作码">opcode 操作码</h3>
<p>在 68K 汇编语言中，操作码（opcode）是指令的核心部分，定义了要执行的操作。以下是一些常用的 68K 操作码及其功能：</p>
<h4 id="常用操作码">常用操作码</h4>
<p>注意大部分操作码都可以添加结尾.W表示字（2个字节16位）.L表示双字(4个字节32位)，.B（1个字节8位）</p>
<h5 id="数据传送">数据传送</h5>
<pre><code>- `MOVE`：将数据从一个位置移动到另一个位置。
    - 例：`MOVE.W D0, D1`（将 D0 的值移动到 D1）
- `MOVEA`：将地址从一个位置移动到另一个位置。
    - 例：`MOVEA.L A0, A1`（将 A0 的地址移动到 A1）
</code></pre>
<h5 id="算术运算">算术运算</h5>
<pre><code>- `ADD`：将两个操作数相加。
    - 例：`ADD.W D0, D1`（将 D0 的值加到 D1）
- `SUB`：从一个操作数中减去另一个操作数。
    - 例：`SUB.W D1, D0`（从 D0 中减去 D1）
- `MULS`：有符号乘法。
    - 例：`MULS D0, D1`（将 D0 和 D1 相乘，结果存储在 D1）
- `DIVS`：有符号除法。
    - 例：`DIVS D0, D1`（将 D1 除以 D0，结果存储在 D1）
</code></pre>
<h5 id="逻辑运算">逻辑运算</h5>
<pre><code>- `AND`：按位与运算。
    - 例：`AND.W D0, D1`（D1 与 D0 按位与）
- `OR`：按位或运算。
    - 例：`OR.W D0, D1`（D1 与 D0 按位或）
- `EOR`：按位异或运算。
    - 例：`EOR.W D0, D1`（D1 与 D0 按位异或）
- `NOT`：按位取反。
    - 例：`NOT.W D0`（D0 的值取反）
</code></pre>
<h5 id="控制流">控制流</h5>
<pre><code>常用如下：
- `BRA`：无条件跳转。
    - 例：`BRA label`（跳转到指定标签）
- `BEQ`：如果相等则跳转。
    - 例：`BEQ label`（如果零标志位被设置，则跳转）
- `BNE`：如果不相等则跳转。
    - 例：`BNE label`（如果零标志位未设置，则跳转）
- `JSR`：跳转到子程序。
    - 例：`JSR subroutine`（跳转到子程序并保存返回地址）
- `RTS`：从子程序返回。
    - 例：`RTS`（返回到调用子程序的地址）
</code></pre>
<h6 id="分支跳转">分支跳转</h6>
<p>该指令将在程序中引发分支，如果某些标志被设置。共有十五种检查标志的方法。每种方法都有一个由两个字母组成的符号，用于替换 &ldquo;cc&rdquo; 在 &ldquo;Bcc&rdquo; 中。</p>
<ul>
<li><strong>BCC</strong>：分支如果进位标志清除 - 当 C 标志为 0 时分支。</li>
<li><strong>BCS</strong>：分支如果进位标志设置 - 当 C 标志为 1 时分支。</li>
<li><strong>BEQ</strong>：分支如果相等 - 当 Z 标志为 1 时分支。</li>
<li><strong>BNE</strong>：分支如果不相等 - 当 Z 标志为 0 时分支。</li>
<li><strong>BGE</strong>：分支如果大于或等于 - 当 N 和 V 相等时分支。</li>
<li><strong>BGT</strong>：分支如果大于 - 当 N 和 V 相等且 Z=0 时分支。</li>
<li><strong>BHI</strong>：分支如果高于 - 当 C 和 Z 都为 0 时分支。</li>
<li><strong>BLE</strong>：分支如果小于或等于 - 当 Z=1 或 N 和 V 不同时分支。</li>
<li><strong>BLS</strong>：分支如果小于或相同 - 当 C=1 或 Z=1 时分支。</li>
<li><strong>BLT</strong>：分支如果小于 - 当 N 和 V 不同时分支。</li>
<li><strong>BMI</strong>：分支如果负 - 当 N=1 时分支。</li>
<li><strong>BPL</strong>：分支如果正 - 当 N=0 时分支。</li>
<li><strong>BVC</strong>：分支如果溢出标志清除 - 当 V=0 时分支。</li>
<li><strong>BVS</strong>：分支如果溢出标志设置 - 当 V=1 时分支。</li>
<li><strong>BRA</strong>：无条件分支 - 始终分支。</li>
</ul>
<blockquote>
<p>上面这些opcode根据标志触发跳转，只能跳转到label，注意进入label后会往下执行，和函数调用不一样，函数调用会返回，继续执行之前代码的下一行，这个不会，是直接跳转过去不回来了。</p></blockquote>
<p>例子：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>    ORG    $1000
START:                  ; first instruction of program

* Put program code here
input:
    move.b #4,d0
    TRAP #15
    CMP #0,d1
    BNE input ;如果不等于0跳转到input标签，继续让输入数字
    BEQ exit  ;如果等于0直接退出

label

exit:
    SIMHALT             ; halt simulator

* Put variables and constants here

    END    START        ; last line of source</code></pre></div>
<h6 id="地址跳转">地址跳转</h6>
<p>JMP（跳转）用于将程序控制转移到一个有效地址。它实际上相当于 MOVE.L xxx, PC，因为它将程序计数器更改为一个有效地址（计算得出）。</p>
<blockquote>
<p>注意JMP是无条件跳转，相对于B开头的跳转，他也支持 JMP label的语法，同时他也支持直接JMP 地址的跳转。</p></blockquote>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>    ORG    $1000
START:                  ; first instruction of program

* Put program code here
input:
    move.b #4,d0
    TRAP #15
    CMP #0,d1
    BNE  input ;如果不等于0跳转到input标签，继续让输入数字
    BEQ exit  ;如果等于0直接退出

label

exit:
    LEA quit,a0 ;=0跳转到这里后，将quit的地址给到a0，JMP直接跳转到地址,相当于：move.l a0,PC（这是伪代码）
    JMP (a0) ;如果想跳转到a0的下一个地址，可以1(a0) 或者n(a0),当然也可以直接JMP quit
    
quit:
    SIMHALT             ; halt simulator

* Put variables and constants here

    END    START        ; last line of source</code></pre></div>
<h6 id="子程序跳转">子程序跳转</h6>
<p>JSR/BSR（跳转到子例程）与 JMP（无条件跳转）类似，但在跳转之前，JSR 会将跳转指令后面的地址压入栈中，这样可以通过 RTS（返回子例程）指令返回，也就相当于调用函数，函数执行完了，执行代码的下一行。</p>
<blockquote>
<p>BSR适合同一代码段里的label直接调用，是相对掉哟个，JSR适合指定一个绝对地址调用(比如JSR $5000) ,但是实际上两个可以互相替换，没啥区别。</p></blockquote>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>    ORG    $1000
START:                  ; first instruction of program

* Put program code here
input:
    JSR input_notion  ;JSR执行完后会自动执行下一行代码，B开头的跳过去就不回来了
    move.b #4,d0
    TRAP #15
    CMP #0,d1
    BNE  input ;如果不等于0跳转到input标签，继续让输入数字
    BEQ exit  ;如果等于0直接退出
input_notion: ;屏幕上输出提示语
    MOVE    #14,D0
    LEA        INPUT_STR,A1
    TRAP        #15
    RTS  ;注意返回了会运行调用这个函数的下一行
confirm_exit      *屏幕上输出确认提示语
    MOVE    #14,D0
    LEA        CONFIRM_STR,A1
    TRAP        #15
    RTS
exit:
    JSR confirm_exit
    move.b #4,d0
    TRAP #15
    CMP #0,d1
    BEQ quit
    BNE input
quit:
    SIMHALT             ; halt simulator

* Put variables and constants here
INPUT_STR: dc.b &#39;please input number(exit=0):&#39;,0
CONFIRM_STR: dc.b &#39;confirm exit(:exit=0,not=1):&#39;,0
    END    START        ; last line of source</code></pre></div>
<p>效果
<a href="#R-image-ced0e3627d9db4eb08a0d53574d2d706" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/a8fbf94b4df64b2ab142894a69ff73db.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ced0e3627d9db4eb08a0d53574d2d706"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/a8fbf94b4df64b2ab142894a69ff73db.png"></a></p>
<h5 id="位操作">位操作</h5>
<pre><code>- `SHL`：左移。
    - 例：`SHL.W #1, D0`（D0 左移 1 位）
- `SHR`：右移。
    - 例：`SHR.W #1, D0`（D0 右移 1 位）
- `ROL`：循环左移。
    - 例：`ROL.W #1, D0`（D0 循环左移 1 位）
- `ROR`：循环右移。
    - 例：`ROR.W #1, D0`（D0 循环右移 1 位）
</code></pre>
<h5 id="比较">比较</h5>
<pre><code>- `CMP`：比较两个操作数。
    - 例：`CMP.W D0, D1`（比较 D0 和 D1 的值）
</code></pre>
<h5 id="堆栈操作">堆栈操作</h5>
<pre><code>- `PUSH`：将数据压入堆栈。
    - 例：`PUSH.W D0`（将 D0 的值压入堆栈）
- `POP`：从堆栈弹出数据。
    - 例：`POP.W D0`（从堆栈弹出值到 D0）
</code></pre>
<h4 id="io操作码">IO操作码</h4>
<p>TRAP #15 被用于触发 I/O.  不同的io流任务存储在： D0.
参考chm：
<a href="#R-image-27408f5ce2733e4905bf068be85f1888" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/0b6a0184f9174acbbad6ba23080abe6f.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-27408f5ce2733e4905bf068be85f1888"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/0b6a0184f9174acbbad6ba23080abe6f.png"></a>
常用的输入输出任务：</p>
<ul>
<li>14:  将A1地址对应的字符串输出 以0结尾结束。</li>
<li>13：将A1地址对应的字符串输出 以0结尾结束，加上\r\n换行。</li>
<li>2: 从控制台获取一个字符串回车后存储在A1地址中 0结尾。</li>
<li>4：读取一个数字写入D1.L中。</li>
</ul>
<p>例子</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>START   ORG     $1000   Program load address.
        move    #14,D0 ;设置14号任务打印A1地址字符串
        lea     text,A1  ;获text地址到A1
        trap    #15     ;激活任务
        SIMHALT        

text    dc.b    &#39;Hello World&#39;,0   ;0表示字符串结束
        END     START   End of source with start address specified.</code></pre></div>
<h4 id="其他操作码">其他操作码</h4>
<p>关于更加详情的指令参考chm
<a href="#R-image-dd7f9b69ddac8cc3023bd1f214aaa032" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/de46135454ab4893bd7f11f2bdf8b81b.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dd7f9b69ddac8cc3023bd1f214aaa032"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/de46135454ab4893bd7f11f2bdf8b81b.png"></a></p>
<h3 id="directives-指令">directives 指令</h3>
<p>指令是汇编器需要遵循的指令。它们占据源代码行中的第二个字段，与指令操作码占据的位置相同，但指令并不是 68000 操作码。 &ldquo;DC&rdquo; 和 &ldquo;DCB&rdquo; 是唯一会导致数据被添加到输出文件中的指令。指令还可以用于控制宏的汇编、条件汇编和结构化语法。</p>
<p>在以下描述中，选项项用方括号 [] 表示。用斜体显示的项应替换为适当的语法。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>Usage:
[label] directive[.size] [data,data,...]
   ^                 ^         ^
    \_________________\_________\_____ varies by directive</code></pre></div>
<h4 id="dc指令">DC指令</h4>
<ul>
<li><strong>全称</strong>：Define Constant（定义常量）</li>
<li><strong>用途</strong>：用于定义并初始化数据常量。<code>DC</code> 指令可以用于定义一个或多个初始值，这些值会被存储在程序的输出文件中。</li>
<li><strong>内存分配</strong>：<code>DC</code> 指令会在程序的内存中分配实际的存储空间，并将指定的值写入该空间。</li>
<li><strong>示例</strong>：
使用语法：</li>
</ul>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>Usage:
[label] DC.size data,data,...</code></pre></div>
<p>例子：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>VALUE1 DC 10          ; 定义常量 VALUE1，值为 10
VALUE2 DC 20, 30      ; 定义常量 VALUE2，值为 20 和 30</code></pre></div>
<ul>
<li><strong>特性</strong>：
<ul>
<li>定义的值在程序运行时是不可更改的。</li>
<li>实际在内存中占用空间。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意下面的代码修改地址的值是非法的，常量无法修改</p></blockquote>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>START:                  ; first instruction of program
    lea usercount,A0
    move.b 20,(A0) ;修改A0地址的常量这是非法的。
* Put program code here

    SIMHALT             ; halt simulator

* Put variables and constants here
    ORG    $1200
usercount    dc.b    10,20
                    dc.w    23</code></pre></div>
<p><a href="#R-image-b3d289500cbed313acfbd9b8274ca0e2" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/a6da915af3dd43e6ac82143539a7bb63.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b3d289500cbed313acfbd9b8274ca0e2"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/a6da915af3dd43e6ac82143539a7bb63.png"></a></p>
<h4 id="equ-指令">EQU 指令</h4>
<ul>
<li>
<p><strong>全称</strong>：Equate（等于）</p>
</li>
<li>
<p><strong>用途</strong>：用于定义一个符号并将其与一个值关联。<code>EQU</code> 定义的值在整个程序中是不可更改的，通常用于定义常量或符号地址，类似于c语言的#define在预编译将对应引用的地方替换为值。</p>
</li>
<li>
<p><strong>内存分配</strong>：<code>EQU</code> 不会在内存中分配实际的存储空间。它只是创建一个符号，所有使用该符号的地方都会被替换为其定义的值。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<p><code>MAX_SIZE EQU 100      ; 定义常量 MAX_SIZE，值为 100</code></p>
</li>
<li>
<p><strong>特性</strong>：</p>
<ul>
<li>一旦定义，<code>EQU</code> 的值不能被修改。</li>
<li>不占用内存空间，编译时进行替换</li>
</ul>
</li>
</ul>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>        ORG    $1000          ; 程序起始地址
START:           ; 将立即数 10 移动到 D0 寄存器

        ; 定义常量
MAX_COUNT EQU 2              ; 定义 MAX_COUNT 为 100
START_VALUE EQU 1             ; 定义 START_VALUE 为 10
        MOVE.B #10, D0
        ADD.B #MAX_COUNT, D0     ; 将 MAX_COUNT (100) 加到 D0
        SUB.B #START_VALUE, D0    ; 将 START_VALUE (10) 从 D0 中减去
        SIMHALT                  ; 停止模拟器

        ORG    $1200            ; 数据段起始地址
    END    START</code></pre></div>
<p><a href="#R-image-ceb2d2600d3e3365c9468422d3ed3789" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/f188f1e8d8d448339c9af3dca49ceb70.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ceb2d2600d3e3365c9468422d3ed3789"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/f188f1e8d8d448339c9af3dca49ceb70.png"></a></p>
<h4 id="set-指令">SET 指令</h4>
<ul>
<li>
<p><strong>用途</strong>：用于定义一个符号并赋予一个初始值，但与 <code>DC</code> 不同的是，<code>SET</code> 定义的值是可更改的。<code>SET</code> 通常用于在程序运行时动态地改变值。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<p><code>COUNT SET 0            ; 定义符号 COUNT，初始值为 0 COUNT SET COUNT + 1    ; 重新定义 COUNT，值为 COUNT + 1</code></p>
</li>
<li>
<p><strong>内存分配</strong>：<code>SET</code> 指令并不分配实际的存储空间来存储值，而是定义一个符号，允许在程序中动态地改变该符号的值。</p>
</li>
</ul>
<h4 id="ds-指令">DS 指令</h4>
<ul>
<li>
<p><strong>全称</strong>：Define Space（定义空间）</p>
</li>
<li>
<p><strong>用途</strong>：用于定义一块未初始化的内存空间。<code>DS</code> 指令只分配内存，但不初始化这些内存的值，随时可改。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<p><code>BUFFER DS 256     ; 定义一个大小为 256 字节的缓冲区</code></p>
</li>
<li>
<p><strong>内存分配</strong>：<code>DS</code> 指令会在输出文件中分配指定大小的内存空间，但这些空间的初始值是未定义的（通常是随机值或零，具体取决于系统）。</p>
</li>
</ul>
<p>定义一个100字节的空间，可以理解为数组，将MULT_TABLE数字第一个位置设置为：12</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>    ORG    $1000
START:                  ; first instruction of program

* Put program code here
    move.B #0,D0
    LEA MULT_TABLE, A0
    MOVE.B #12,(A0, D0)
    SIMHALT             ; halt simulator
    ORG    $1200
* Put variables and constants here
    MULT_TABLE:        ; 乘法表的存储位置
        DS.B 10 * 10   ; 预留 10x10 的空间
    END    START        ; last line of source</code></pre></div>
<h4 id="其他指令">其他指令</h4>
<p>参考chm
<a href="#R-image-7c6b73e1950e10b7fd3df22938193b3d" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/3af428ed066844588764c5e41580e5dc.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7c6b73e1950e10b7fd3df22938193b3d"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/3af428ed066844588764c5e41580e5dc.png"></a></p>
<h3 id="寄存器">寄存器</h3>
<h4 id="程序计数器pc">程序计数器（PC）</h4>
<p>程序计数器（有时在不同的体系结构中也称为指令指针或指令地址寄存器）保存下一条将要执行的指令的内存地址。每当 CPU 执行一条指令时，PC 的值会自动更新，以指向下一条指令。
更新机制：在大多数情况下，PC 在指令执行后自动加一（或加上指令的长度），以指向下一条指令的地址。
编写一个简单程序 运行，默认会从start:的写一条语句开始，PC寄存器指向初始代码的地址（注意有效的代码时左侧绿色点点的，其他都是指令或者注释）
<a href="#R-image-4cbb373ee72f93c99230d751825b606e" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/395e58ac836c451c8a4004ba499a6a8d.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4cbb373ee72f93c99230d751825b606e"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/395e58ac836c451c8a4004ba499a6a8d.png"></a>
按下F8执行到下一条
<a href="#R-image-0c2d18c8d1ab50f2f83a6c2dcd37152b" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/82af53ed1d804b14a317fd3bcc0a504e.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0c2d18c8d1ab50f2f83a6c2dcd37152b"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/82af53ed1d804b14a317fd3bcc0a504e.png"></a>
我这里将usercount的地址指向A0  ,同时加了ORG    $1200从1200这个地址写入。点击A0的地址可以查看内存：
<a href="#R-image-27f60405b0fcdd9e935da8e25ab685db" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/578a7e75169f44fe9871fcfd518b97cb.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-27f60405b0fcdd9e935da8e25ab685db"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/578a7e75169f44fe9871fcfd518b97cb.png"></a></p>
<h4 id="状态寄存器sr">状态寄存器（SR）</h4>
<p>在 68k（Motorola 68000）架构中，状态寄存器（SR，Status Register）是一个重要的寄存器，用于存储处理器的状态信息和控制标志。状态寄存器的内容影响程序的执行流程，特别是在条件跳转和中断处理时。以下是对 68k 状态寄存器的详细介绍：</p>
<h5 id="状态寄存器的结构">状态寄存器的结构</h5>
<p>68k 的状态寄存器是一个 16 位的寄存器，包含多个标志位。主要的标志位包括：</p>
<ol>
<li>
<p><strong>N（Negative）</strong>:</p>
<ul>
<li>表示最近一次运算的结果是否为负数。</li>
<li>如果结果的最高位（符号位）为 1，则 N 标志被设置。</li>
</ul>
</li>
<li>
<p><strong>Z（Zero）</strong>:</p>
<ul>
<li>表示最近一次运算的结果是否为零。</li>
<li>如果结果为 0，则 Z 标志被设置。</li>
</ul>
</li>
<li>
<p><strong>V（Overflow）</strong>:</p>
<ul>
<li>表示最近一次运算是否发生了溢出。</li>
<li>溢出通常发生在有符号数运算中，当结果超出可表示的范围时，V 标志被设置。</li>
</ul>
</li>
<li>
<p><strong>C（Carry）</strong>:</p>
<ul>
<li>表示最近一次运算是否产生了进位或借位。</li>
<li>在加法运算中，如果产生了进位，C 标志被设置；在减法运算中，如果发生了借位，C 标志也会被设置。</li>
</ul>
</li>
<li>
<p><strong>I（Interrupt Mask）</strong>:</p>
<ul>
<li>这是一个 3 位的中断屏蔽位，控制中断的响应。</li>
<li>I0、I1 和 I2 位用于设置中断优先级，值越大，响应的中断优先级越低。</li>
</ul>
</li>
<li>
<p><strong>T（Trace）</strong>:</p>
<ul>
<li>这是一个单个位，用于启用或禁用跟踪模式。</li>
<li>当 T 位被设置时，处理器将在每个指令执行后产生一个中断，适用于调试。</li>
</ul>
</li>
<li>
<p><strong>S（Supervisor）</strong>:</p>
<ul>
<li>这是一个单个位，指示当前处理器是否处于特权模式（超级用户模式）。</li>
<li>当 S 位被设置时，处理器处于超级用户模式，允许执行特权指令。</li>
</ul>
</li>
</ol>
<h5 id="状态寄存器的作用">状态寄存器的作用</h5>
<ul>
<li><strong>条件跳转</strong>: 状态寄存器中的标志位用于条件跳转指令（如 <code>BEQ</code>、<code>BNE</code> 等），根据运算结果的状态决定程序的执行路径。</li>
<li><strong>中断处理</strong>: 中断标志位控制中断的响应，允许或禁止特定级别的中断。</li>
<li><strong>运算结果的状态</strong>: 通过检查 N、Z、V 和 C 标志，程序可以根据运算结果的状态做出相应的处理。</li>
</ul>
<h5 id="示例">示例</h5>
<p>以下是一个简单的示例，展示如何使用状态寄存器的标志位：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>    MOVE.L #5, D0          ; 将 5 加载到 D0
    MOVE.L #3, D1          ; 将 3 加载到 D1
    SUB.L D1, D0           ; D0 = D0 - D1，结果为 2

    ; 检查 Z 标志
    BEQ zero_result        ; 如果 Z 标志为 1，跳转到 zero_result

    ; 检查 N 标志
    BPL positive_result     ; 如果 N 标志为 0，跳转到 positive_result

zero_result:
    ; 处理结果为零的情况
    ; ...

positive_result:
    ; 处理结果为正的情况
    ; ...</code></pre></div>
<h4 id="数据寄存器d">数据寄存器（D)</h4>
<p>在 68000（68k）架构中，D 寄存器（数据寄存器）是用于存储数据和操作数的寄存器。68k 处理器有 8 个数据寄存器，分别为 D0 到 D7。</p>
<h5 id="d-寄存器的特点">D 寄存器的特点</h5>
<ol>
<li>
<p><strong>数量</strong>:</p>
<ul>
<li>68k 处理器有 8 个数据寄存器，编号为 D0 到 D7。</li>
</ul>
</li>
<li>
<p><strong>大小</strong>:</p>
<ul>
<li>每个 D 寄存器的大小为 32 位（4 字节），可以存储 32 位的整数或指针。</li>
</ul>
</li>
<li>
<p><strong>用途</strong>:</p>
<ul>
<li>D 寄存器主要用于存储运算的操作数、结果以及临时数据。它们在算术运算、逻辑运算、数据传输等操作中被广泛使用。</li>
</ul>
</li>
<li>
<p><strong>寻址模式</strong>:</p>
<ul>
<li>D 寄存器可以与多种寻址模式结合使用，支持直接寻址、间接寻址等方式，方便数据的访问和操作。</li>
</ul>
</li>
<li>
<p><strong>操作</strong>:</p>
<ul>
<li>D 寄存器可以参与各种指令的操作，如加法、减法、位运算等。指令可以直接对 D 寄存器进行操作，也可以将 D 寄存器的值存储到内存中或从内存中加载数据。</li>
</ul>
</li>
</ol>
<h5 id="d-寄存器的使用场景">D 寄存器的使用场景</h5>
<ul>
<li><strong>算术运算</strong>: D 寄存器用于存储参与运算的数值。</li>
<li><strong>数据传输</strong>: 在数据传输指令中，D 寄存器可以作为源或目标。</li>
<li><strong>函数参数</strong>: 在调用子程序时，D 寄存器常用于传递参数。</li>
</ul>
<h5 id="示例-1">示例</h5>
<p>以下是一个简单的汇编代码示例，展示如何使用 D 寄存器进行基本的算术运算：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>    MOVE.L #10, D0        ; 将 10 加载到 D0 寄存器
    MOVE.L #5, D1         ; 将 5 加载到 D1 寄存器
    ADD.L D1, D0          ; D0 = D0 + D1，D0 现在为 15</code></pre></div>
<h4 id="地址寄存器a">地址寄存器（A)</h4>
<p>68000（68k）架构中，A 寄存器（地址寄存器）是用于存储内存地址的寄存器。68k 处理器有 8 个地址寄存器，分别为 A0 到 A7。以下是对 A 寄存器的详细描述：</p>
<h5 id="a-寄存器的特点">A 寄存器的特点</h5>
<ol>
<li>
<p><strong>数量</strong>:</p>
<ul>
<li>68k 处理器有 8 个地址寄存器，编号为 A0 到 A7。</li>
</ul>
</li>
<li>
<p><strong>大小</strong>:</p>
<ul>
<li>每个 A 寄存器的大小为 32 位（4 字节），可以存储 32 位的内存地址。</li>
</ul>
</li>
<li>
<p><strong>用途</strong>:</p>
<ul>
<li>A 寄存器主要用于存储内存地址，支持数据的加载和存储操作。它们在指令中用于指向数据或指令的内存位置。</li>
</ul>
</li>
<li>
<p><strong>寻址模式</strong>:</p>
<ul>
<li>A 寄存器可以与多种寻址模式结合使用，包括直接寻址、间接寻址、基址寻址和相对寻址等。这使得程序能够灵活地访问内存中的数据。</li>
</ul>
</li>
<li>
<p><strong>堆栈指针</strong>:</p>
<ul>
<li>A7 寄存器通常用作堆栈指针（SP），指向当前堆栈的顶部。堆栈用于存储函数调用的返回地址、局部变量等。</li>
</ul>
</li>
</ol>
<h5 id="a-寄存器的使用场景">A 寄存器的使用场景</h5>
<ul>
<li><strong>内存访问</strong>: A 寄存器用于指向数据在内存中的位置，支持数据的读取和写入。</li>
<li><strong>函数调用</strong>: 在函数调用中，A 寄存器可以用于传递参数和返回地址。</li>
<li><strong>堆栈管理</strong>: A7 寄存器作为堆栈指针，管理函数调用的堆栈帧。</li>
</ul>
<h5 id="示例-2">示例</h5>
<p>以下是一个简单的汇编代码示例，展示如何使用 A 寄存器进行内存操作：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>   LEA array, A0         ; 将数组的地址加载到 A0 寄存器
    MOVE.L (A0), D0       ; 从 A0 指向的地址加载数据到 D0 寄存器
    ADD.L #1, D0          ; D0 = D0 + 1
    MOVE.L D0, (A0)       ; 将 D0 的值存储回 A0 指向的地址</code></pre></div>
<h4 id="堆栈寄存器ss">堆栈寄存器（SS)</h4>
<p>在68k架构中，堆栈寄存器是用于管理程序运行时的堆栈的关键组件。68k系列处理器使用一个专用的寄存器来指向当前堆栈的顶部，这个寄存器被称为堆栈指针（Stack Pointer）。</p>
<p>在68k架构中，堆栈指针寄存器通常是 A7（地址寄存器7），它指向当前堆栈的顶部。
堆栈是一个后进先出（LIFO）的数据结构，用于存储临时数据，如函数调用的返回地址、局部变量和中断处理程序的上下文。</p>
<p><a href="#R-image-89e52390d47b54a4aa9ba31eebc68f13" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/50c1a702e1de4ffc901b676836df4787.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-89e52390d47b54a4aa9ba31eebc68f13"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/50c1a702e1de4ffc901b676836df4787.png"></a></p>
<h5 id="堆栈操作-1">堆栈操作</h5>
<p>我们来看下堆栈指针的移动和数据写入逻辑。
在68k汇编语言中，-(A7) 和 (A7)+ 分别用于表示压栈和出栈操作。
执行代码</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>move.l #10,-(a7)</code></pre></div>
<p>未执行前原始堆栈地址A7指向：01000000，没有任何数据
<a href="#R-image-2e8e09328fadfc011ba1fc4eaf062403" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/eccbc54b8ba1479fb13c53186bd1fec1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2e8e09328fadfc011ba1fc4eaf062403"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/eccbc54b8ba1479fb13c53186bd1fec1.png"></a>
执行：move.l #10,-(a7)
<a href="#R-image-0a65d14525594098a959ce95e34ce88b" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/a90b75c243bb40bf8f975924cd654e83.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0a65d14525594098a959ce95e34ce88b"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/a90b75c243bb40bf8f975924cd654e83.png"></a>
执行：move.l #20,-(a7)
<a href="#R-image-d4fbfe226db7e53739563514cd392cdd" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/1de0f0619a6d4e6cbbf7e094eff0d14f.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d4fbfe226db7e53739563514cd392cdd"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/1de0f0619a6d4e6cbbf7e094eff0d14f.png"></a>
执行出栈：move.l (a7)+,d0
<a href="#R-image-e94b651e26aaac0849dab419e471d2e6" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/21b9970123594b6eab62352fdfadd2f6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e94b651e26aaac0849dab419e471d2e6"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/21b9970123594b6eab62352fdfadd2f6.png"></a></p>
<h5 id="std函数模拟">std函数模拟</h5>
<p>我们知道c语言的std约定是：调用函数先压入执行代码的后一个位置，然后参数从右往左压入，在函数内部出栈从左（后入先出）往右获取参数，执行完成获取代码执行的位置，跳转。
我们来模拟这个过程：
假设函数:
public int add(int a,int b)
用98k模拟堆栈实现：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>    ORG    $1000
START:                  ; first instruction of program

* Put program code here
    move.l #10,-(a7) #第二个参数压栈。
    move.l #20,-(a7) #第一个参数压栈。
    LEA *+12, A0  *计算下LEA占用4个字节，一直到move.l d0,d2是12个字节，*+12就是从PC当前位置+12个就是下一个执行代码的位置
    move.l a0,4(a7) *将下一个执行的地址压栈
    JMP add
    move.l d0,d2
    SIMHALT             ; halt simulator
    
add:
   move.l (a7)+,a0  ;地址出栈
   move.l (a7)+,d0 ;第一个参数出栈
   move.l (a7)+,d1 ;第二个参数出栈
   add.l d1,d0
   JMP (a0)
 
   
* Put variables and constants here

    END    START        ; last line of source</code></pre></div>
<h3 id="案例99乘法表">案例(9*9乘法表)</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>*-----------------------------------------------------------
* Title      :
* Written by :
* Date       :
* Description:
*-----------------------------------------------------------
    ORG    $1000
START:                  ; first instruction of program

* Put program code here
    move.b #start_index,d2 ;行索引
    move.b #start_index,d3  ;列索引
row:
    jsr print_str_line ;到row的部分就添加一个换行，jsr调用子程序，子程序需要RTS返回
    add.b #1,d2 ;每运行一次+1
    move.b #start_index,d3
    cmp #end_index+1,d2 ;到达最后一行+1直接退出
    BEQ exit
    col:
        add.b #1,d3
        move.b d2,d1
        jsr print_num ;打印行的数字
        lea tmp_str,a1
        move.b #&#39;*&#39;,(a1) ;打印一个*
        jsr print_str
        move.b d3,d1
        jsr print_num ;打印一个列的数字
        move.b #&#39;=&#39;,(a1) 
        jsr print_str ;打印一个=
        move.b #1,d4
        muls d2,d4
        muls d3,d4
        move.b d4,d1
        jsr print_num ;打印一个列的数字
        move.b #&#39; &#39;,(a1) 
        jsr print_str ;打印一个空格
        cmp d3,d2
        BEQ row
        BNE col
print_num:
    move.b #3,d0
    TRAP #15 
    RTS    
print_str:
    move.b #0,1(a1) ;打印字符的结尾
    move.b #14,d0
    TRAP #15 
    RTS   
print_str_line:
    move.b #0,(a1) ;打印字符的结尾
    move.b #13,d0
    TRAP #15 
    RTS       
exit:
    SIMHALT             ; halt simulator

* Put variables and constants here
tmp_str ds.b 2
end_index equ 9
start_index equ 0
    END    START        ; last line of source</code></pre></div>
<p>效果
<a href="#R-image-edfebb9030968e25505f9eb36608a95a" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/b0b4e60079fc4d579810669a390d1d38.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-edfebb9030968e25505f9eb36608a95a"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/languages/assembly/68000_01_base.md.images/b0b4e60079fc4d579810669a390d1d38.png"></a>
其他68k速查的在线文档：</p>
<ul>
<li>指令列表：https://github.com/prb28/m68k-instructions-documentation?tab=readme-ov-file</li>
<li>0基础入门：https://mrjester.hapisan.com/04_MC68/</li>
<li>romhack相关所有资源（文档工具）：https://github.com/zengfr/romhack</li>
<li>常用指令备忘录：https://github.com/zengfr/romhack/blob/adf6412c2a969486918bb00c18a2c989abdeaad5/M68000/M68000%E6%8C%87%E4%BB%A4-%E5%A4%87%E5%BF%98%E8%A1%A5%E5%85%85(%E6%95%B4%E7%90%86zengfr).txt</li>
</ul>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> Sep 18, 2025
  </footer>
</article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">
          <a id="R-logo" class="R-default" href="/docs/index.html">
            <div class="logo-title">liaomin416100569博客</div>
          </a>
        </div>
        <search><form action="/docs/search/index.html" method="get">
          <div class="searchbox default-animation">
            <button class="search-detail" type="submit" title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
            <label class="a11y-only" for="R-search-by">Search</label>
            <input data-search-input id="R-search-by" name="search-by" class="search-by" type="search" placeholder="Search...">
            <button class="search-clear" type="button" data-search-clear="" title="Clear search"><i class="fas fa-times" title="Clear search"></i></button>
          </div>
        </form></search>
      </div>
      <div id="R-homelinks" class="default-animation homelinks">
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-homelinks">
          <ul class="space collapsible-menu">
            <li class="" data-nav-id="/docs/index.html"><a class="padding" href="/docs/index.html"><i class="fa-fw fas fa-home"></i> Home</a></li>
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-headercontrols">
          <ul class="">
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div class="R-sidebarmenu R-shortcutmenu-main">
          <ul class="enlarge morespace collapsible-menu">
            <li class="parent " data-nav-id="/docs/programming/index.html"><a class="padding" href="/docs/programming/index.html">编程开发</a><ul id="R-subsections-e3fc01b477dbaf64a8f5013a3dab5c5b" class="collapsible-menu">
            <li class="parent alwaysopen " data-nav-id="/docs/programming/languages/index.html"><a class="padding" href="/docs/programming/languages/index.html">编程语言</a><ul id="R-subsections-1bbde7fb0c312ba940b425df5a4caf67" class="collapsible-menu">
            <li class="alwaysopen " data-nav-id="/docs/programming/languages/gcc/index.html"><a class="padding" href="/docs/programming/languages/gcc/index.html">c语言</a><ul id="R-subsections-e8c9b5cff4c7849bafc19d21e0433f7f" class="collapsible-menu"></ul></li>
            <li class="parent alwaysopen " data-nav-id="/docs/programming/languages/assembly/index.html"><a class="padding" href="/docs/programming/languages/assembly/index.html">汇编语言</a><ul id="R-subsections-664e07814ed6bbd77b351b341bff28e6" class="collapsible-menu">
            <li class="active " data-nav-id="/docs/programming/languages/assembly/68000_01_base/index.html"><a class="padding" href="/docs/programming/languages/assembly/68000_01_base/index.html">68000汇编实战01-编程基础</a></li></ul></li></ul></li>
            <li class="alwaysopen " data-nav-id="/docs/programming/ai/index.html"><a class="padding" href="/docs/programming/ai/index.html">人工智能</a><ul id="R-subsections-9d06be7bd8c736c09a65fb0b91b71d0e" class="collapsible-menu"></ul></li>
            <li class="alwaysopen " data-nav-id="/docs/programming/plugins/index.html"><a class="padding" href="/docs/programming/plugins/index.html">插件开发</a><ul id="R-subsections-de66f54cff99288ca68bfcb5bb0439ae" class="collapsible-menu"></ul></li></ul></li>
            <li class="" data-nav-id="/docs/devops/index.html"><a class="padding" href="/docs/devops/index.html">运维一体化</a><ul id="R-subsections-389d4feb4920b919bcbc0b1e9947dace" class="collapsible-menu"></ul></li>
            <li class="" data-nav-id="/docs/security/index.html"><a class="padding" href="/docs/security/index.html">安全攻防</a><ul id="R-subsections-66815ecaaecfc1c209e5637d03b258b2" class="collapsible-menu"></ul></li>
          </ul>
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-shortcuts">
          <ul class="space collapsible-menu">
          </ul>
        </div>
        <div id="R-footer-margin"></div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-footercontrols">
          <ul class="">
          </ul>
        </div>
<div id="R-footer"><p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p></div>
      </div>
    </aside>
    <script src="/docs/js/clipboard/clipboard.min.js?1758355652" defer></script>
    <script src="/docs/js/perfect-scrollbar/perfect-scrollbar.min.js?1758355652" defer></script>
    <script src="/docs/js/theme.min.js?1758355652" defer></script>
  </body>
</html>

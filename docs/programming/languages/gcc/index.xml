<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c语言 :: liaomin416100569博客</title>
    <link>https://jiaozi789.github.io/docs/programming/languages/gcc/index.html</link>
    <description></description>
    <generator>Hugo</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 18 Sep 2025 16:55:17 +0800</lastBuildDate>
    <atom:link href="https://jiaozi789.github.io/docs/programming/languages/gcc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>linux下gcc编程01-gcc工具安装和使用</title>
      <link>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_01/index.html</link>
      <pubDate>Thu, 18 Sep 2025 16:55:17 +0800</pubDate>
      <guid>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_01/index.html</guid>
      <description>一。 gcc介绍&#xA;Linux系统下的gcc（GNU C Compiler）是GNU推出的功能强大、性能优越的多平台编译器，是GNU的代表作品之一。&#xA;gcc是可以在多种硬体平台上编译出可执行程序的超级编译器，其执行效率与一般的编译器相比平均效率要高20%~30%。&#xA;gcc编译器能将C、C++语言源程序、汇程式化序和目标程序编译、连接成可执行文件，如果没有给出可执行文件的名字，&#xA;gcc将生成一个名为a.out的文件。在Linux系统中，可执行文件没有统一的后缀，系统从文件的属性来区分可执行文件和不可执 行文件。&#xA;gcc则通过后缀来区别输入文件的类别，下面我们来介绍gcc所遵循的部分约定规则。&#xA;.c为后缀的文件，C语言源代码文件；&#xA;.a为后缀的文件，是由目标文件构成的档案库文件；&#xA;.C，.cc或.cxx 为后缀的文件，是C++源代码文件；&#xA;.h为后缀的文件，是程序所包含的头文件；&#xA;.i 为后缀的文件，是已经预处理过的C源代码文件；&#xA;.ii为后缀的文件，是已经预处理过的C++源代码文件；&#xA;.m为后缀的文件，是Objective-C源代码文件；&#xA;.o为后缀的文件，是编译后的目标文件；&#xA;.s为后缀的文件，是汇编语言源代码文件；&#xA;.S为后缀的文件，是经过预编译的汇编语言源代码文件。&#xA;GCC安装 gcc工具默认未安装未安装在centos系统中 需要通过yum安装 通过yum group 获取到开发工具组（有些系统可能是中文）&#xA;[root@cdh2 vc]# yum group list&#xD;Loaded plugins: fastestmirror&#xD;Loading mirror speeds from cached hostfile&#xD;* base: mirrors.aliyun.com&#xD;* epel: mirror01.idc.hinet.net&#xD;* extras: mirrors.aliyun.com&#xD;* updates: mirrors.aliyun.com&#xD;Available Environment Groups:&#xD;Minimal Install&#xD;Compute Node&#xD;Infrastructure Server&#xD;File and Print Server&#xD;Cinnamon Desktop&#xD;MATE Desktop&#xD;Basic Web Server&#xD;Virtualization Host&#xD;Server with GUI&#xD;GNOME Desktop&#xD;KDE Plasma Workspaces&#xD;Development and Creative Workstation&#xD;Installed Groups:&#xD;Development Tools 这里找到组的名字是 Development Tools</description>
    </item>
    <item>
      <title>linux下gcc编程02-gdb调试工具使用</title>
      <link>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_02/index.html</link>
      <pubDate>Thu, 18 Sep 2025 16:55:17 +0800</pubDate>
      <guid>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_02/index.html</guid>
      <description>一。gdb调试工具简介&#xA;GDB（GNU Debugger）是GCC的调试工具。其功能强大，现描述如下： GDB主要帮忙你完成下面四个方面的功能： 1.启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。 2.可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式） 3.当程序被停住时，可以检查此时你的程序中所发生的事。 4.动态的改变你程序的执行环境。&#xA;gdb调试工具使用必须在应用程序编译时生成调试信息 gcc添加 -g参数&#xA;[root@cdh2 vc]# gcc -g hello.c -o hello gcc常用命令列表&#xA;回车键：重复上一命令&#xA;help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h&#xA;run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r&#xA;start：单步执行，运行程序，停在第一执行语句&#xA;list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l&#xA;set：设置变量的值&#xA;next：单步调试（逐过程，函数直接执行）,简写n&#xA;step：单步调试（逐语句：跳入自定义函数内部执行）,简写s&#xA;backtrace：查看函数的调用的栈帧和层级关系,简写bt&#xA;frame：切换函数的栈帧,简写f&#xA;info：查看函数内部局部变量的数值,简写i&#xA;finish：结束当前函数，返回到函数调用点&#xA;continue：继续运行,简写c&#xA;print：打印值及地址,简写p&#xA;quit：退出gdb,简写q&#xA;break num：在第num行设置断点,简写b&#xA;其他语法参考&#xA;break 10 某行下断点&#xD;break test.c:10 某个文件某行下断点&#xD;break main 某个方法上下断点&#xD;break test.c:main 某个文件某个方法&#xD;如果想在指定的地址设置断点，比如在main函数的地址出设断点。&#xD;可用info add main 获得main的地址如0x80484624，然后用break *0x80484624.&#xD;条件断点就是在如上述指定断点的同时指定进入断点的条件。&#xD;例如：（假如有int 类型变量 index）&#xD;break 10 if index == 3 info breakpoints：查看当前设置的所有断点</description>
    </item>
    <item>
      <title>linux下gcc编程03-make工程管理</title>
      <link>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_03/index.html</link>
      <pubDate>Thu, 18 Sep 2025 16:55:17 +0800</pubDate>
      <guid>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_03/index.html</guid>
      <description>一。 make工程管理器简介&#xA;工程管理器是指管理较多的文件。如果有一个上百个文件的代码构成的项目，&#xA;如果其中只有一个或少数几个文件进行了修改，按照之前所学的Gcc编译工具，就不得不把这所有的文件重新编译一遍，&#xA;因为编译器并不知道哪些文件是最近更新的，而只知道需要包含这些文件才能把源代码编译成可执行文件，&#xA;于是，程序员就不能不再重新输入数目如此庞大的文件名以完成最后的编译工作。&#xA;编译过程是分为编译、汇编、链接不同阶段的，其中编译阶段仅检查语法错误以及函数与变量的声明是否正确声明了，&#xA;在链接阶段则主要完成是函数链接和全局变量的链接。因此，那些没有改动的源代码根本不需要重新编译，而只要把它们重新链接进去就可以了。所以，人们就希望有一个工程管理器能够自动识别更新了的文件代码，同时又不需要重复输入冗长的命令行，这样，Make工程管理器也就应运而生了。&#xA;实际上，Make工程管理器也就是个“自动编译管理器”，这里的“自动”是指它能够根据文件时间戳自动发现更新过的文件而减少编译的工作量，同时，它通过读入Makefile文件的内容来执行大量的编译工作。用户只需编写一次简单的编译语句就可以了。它大大提高了实际项目的工作效率，而且几乎所有Linux下的项目编程均会涉及到它&#xA;1》makefile文件&#xA;Make在执行时，需要一个命名为Makefile或者makefile的文件。Makefile文件描述了整个工程的编译，链接等规则。&#xA;其中包括：1.工程中的哪些源文件需要编译以及如何编译；&#xA;2需要创建哪些库文件以及如何创建这些库文件、&#xA;3如何最后产生我们想要的可执行文件。&#xA;2》makefile语法&#xA;make通过定义规则来决定如何生成文件&#xA;规则：用于说明如何生成一个或者多个目标文件，规则格式如下： 目标:依赖目标&#xA;（以tab空格）命令&#xA;比如&#xA;a:hello.c&#xA;gcc hello.c -o hello&#xA;a就是一个目标名称:hello.c就是目标依赖的文件 这里如果没有依赖其他目标可以放置依赖的文件&#xA;gcc hello.c -o hello 就是执行这个目标的命令 tab间隔隔开&#xA;在源代码目录新建makefile&#xA;a:hello.c&#xD;gcc hello.c -o hello make编译&#xA;[root@localhost vc]# make&#xD;gcc hello.c -o hello 3》多文件的makefile依赖&#xA;假设有如下案例：&#xA;存在一个公用的头文件 a.h（用于定义全局变量和 方法定义）&#xA;#include &lt;stdio.h&gt;&#xD;#include &lt;stdlib.h&gt;&#xD;int add(int p1,int p2); //该方法在mmath.c中实现&#xD;void syso(char* c); //该方法在syso.c中实现 mmath.c实现add方法 内容如下：&#xA;#include &#34;a.h&#34;&#xD;int add(int p1,int p2){&#xD;return p1+p2;&#xD;} syso.c实现syso方法</description>
    </item>
    <item>
      <title>linux下gcc编程04-cmake工程管理</title>
      <link>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_04/index.html</link>
      <pubDate>Thu, 18 Sep 2025 16:55:17 +0800</pubDate>
      <guid>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_04/index.html</guid>
      <description>一。cmake简介&#xA;CMake是一个跨平台的编译、安装、测试以及打包工具；CMake不直接编译软件，而是结合原生构建系统来构建软件。 CMake配置文件是CMakeList.txt文件（每个源码文件夹下都要有一个），CMake根据配置文件再生成Unix的Makefile或VS的solution文件等。 Cmake旨在通过一个配置来解决不同平台编写不同编译配置文件的方法 cmake仅仅帮我们生成编译工程文件,最终编译靠 各自编译器 图解：&#xA;1》 cmake安装 yum -y install cmake 查看版本&#xA;[root@localhost rule]# cmake --version&#xD;cmake version 2.8.12.2 cmake官方向导 https://cmake.org/cmake-tutorial/ 官方文档：https://cmake.org/documentation 老版本在最下面 最简单的配置文件 添加一个hello.c的源码&#xA;#include &lt;stdio.h&gt;&#xD;void main(){&#xD;printf(&#34;hello\n&#34;);&#xD;} 在当前目录下新建CMakeList.txt文件内容&#xA;#CMake最低版本号要求&#xD;cmake_minimum_required (VERSION 2.8)&#xD;#项目信息&#xD;project (demo)&#xD;#指定生成目标 参数1表示生成目标文件的名称 参数2表示源文件&#xD;add_executable(demo hello.c) 执行 (cmake 有cmakelist.txt文件的目录)&#xA;cmake . 执行完成后 发现当前目录下 生成了Makefile文件 使用make 命令就可以编译了&#xA;[root@localhost helloworld]# cmake .&#xD;-- Configuring done&#xD;-- Generating done&#xD;-- Build files have been written to: /root/vc/helloworld&#xD;[root@localhost helloworld]# make &amp;&amp; ./demo&#xD;[100%] Built target demo&#xD;hello</description>
    </item>
    <item>
      <title>linux下gcc编程05-window下开发工具安装</title>
      <link>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_05/index.html</link>
      <pubDate>Thu, 18 Sep 2025 16:55:17 +0800</pubDate>
      <guid>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_05/index.html</guid>
      <description>一。 window下开发环境安装&#xA;Unix下编译通过的C代码,在win32下编译是不能通过的 ,当然Unix 和win32的API都是符合标准C,也就是说,大多数函数调用在unix和win32下是相同的.但是,unix有自己一些独特的API（如fork,spawn,signals,select,sockets等）,如果代码中使用了这些API,在win32下当然找不到对应的库. 但是,这些API的功能在win32中也能实现,也许你已经发现了一个能让window编译Unix风格代码的方法: 1.修改编译器,让window下的编译器把诸如fork的调用翻译成window等价的形式–这就是mingw的做法. 2.修改库,让window提供一个类似unix提供的库,他们对程序的接口如同unix一样,而这些库,当然是由win32的API实现的–这就是cygwin的做法.&#xA;MinGW相比CygWin/gcc来讲，更加贴近win32。因为它几乎支持所有的Win32API。它所连接的程序，不需要任何第三方库即可运行。&#xA;MinGW安装 mingw官网提供是 一个二进制文件 远程安装 mingw-get-setup.exe 官网太慢直接去sourceforage去down下来 https://sourceforge.net/projects/mingw-w64/ 直接地址&#xA;接下来双击一路 等待下载完成 已经下载完成的离线包 500多MB 将bin目录设置到环境变量&#xA;C:\MinGW\bin&gt;gcc --version&#xD;gcc (MinGW.org GCC-6.3.0-1) 6.3.0&#xD;Copyright (C) 2016 Free Software Foundation, Inc.&#xD;This is free software; see the source for copying conditions. There is NO&#xD;warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 二。Clion开发工具&#xA;使用记事本 或者vi在linux直接编写代码 个人感觉效率偏低 有时引入头文件还要去查api 如果有提示 大概方法也能 猜个90%左右 这里推荐jetbrains公司的clion 下载地址（30天的免费使用 ）： http://www.jetbrains.com/clion/&#xA;下载完成后 一路到验证 阶段 点击激活码 （https://jetlicense.nss.im/ 这个网站上有 拷贝进去就可以激活一年试用期）</description>
    </item>
    <item>
      <title>linux下gcc编程06-c语言参考手册</title>
      <link>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_06/index.html</link>
      <pubDate>Thu, 18 Sep 2025 16:55:17 +0800</pubDate>
      <guid>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_06/index.html</guid>
      <description>一。 c语言标准库介绍&#xA;stdlib里的是常用系统函数，跟系统调用相关的，比如内存申请malloc和释放free stdio是标准io函数，比如printf和scanf函数 所有参考函数 来自 ：http://www.he11oworld.com/c-shouce/ http://www.runoob.com/cprogramming/c-tutorial.html&#xA;二。c语言参考案例&#xA;宏定义&#xA;宏是在gcc编译预处理阶段就会执行的代码 //#pragma命令可以让编程者让编译器执行某些事 #include &lt;stdio.h&gt; //包含io流的库 标准的输入和输出 &#34;&#34;首先在当前目录下寻找，如果找不到，再到系统目录中寻找&#xD;&lt;&gt;直接去系统目录中找&#xD;#define True 0&#xD;#define toString(s) #s&#xD;#define concat(x,y) x ## y&#xD;#define add(a,b) a+b&#xD;#define max(a,b) a&gt;b?a:b&#xD;void myadd(int a,int b) {&#xD;}&#xD;int main() {&#xD;printf(&#34;%s\n&#34;,toString(&#34;替换&#34;));//#s 预编译阶段这里编程 printf(&#34;%s\n&#34;,&#34;替换\n&#34;)&#xD;int xy=100;&#xD;printf(&#34;%d\n&#34;,concat(x,y)); //x##y连接成 xy 预编译 这里 printf(&#34;%d\n&#34;,xy)&#xD;printf(&#34;%d\n&#34;,add(10,11)); //这里直接被替换成 printf(&#34;%d\n&#34;,10+11);&#xD;int a=100;&#xD;int b=10;&#xD;printf(&#34;%d\n&#34;,max(a,b)); //这里直接被替换成 printf(&#34;%d\n&#34;,a&gt;b?a:b);&#xD;/**&#xD;* 下列参数在不同的编译器可能会有所不同, 但是一般是可用的:&#xD;__LINE__ 和 __FILE__ 变量表示正在处理的当前行和当前文件.&#xD;__DATE__ 变量表示当前日期,格式为month/day/year(月/日/年).&#xD;__TIME__ 变量描述当前的时间,格式为hour:minute:second(时:分:秒).&#xD;_cplusplus 变量只在编译一个C++程序时定义.&#xD;__STDC__ 变量在编译一个C程序时定义,编译C++时也有可能定义.&#xD;*/&#xD;//获取当前的文件名 当前行号&#xD;printf(&#34;%s--%d\n&#34;, __FILE__,__LINE__ );&#xD;#line 10 &#34;a.cpp&#34; //下一行就变成第10行了 文件名改成了a.cpp可以动修改上面两个变量的值&#xD;int i=1000;&#xD;printf(&#34;%s--%d\n&#34;, __FILE__,__LINE__ );&#xD;#ifdef True //是否定义这个宏 上面已经定义了 不管真假 if系列 #if, #ifdef, #ifndef, #else, #elif, #endif&#xD;printf(&#34;Hello, World!\n&#34;);&#xD;#endif&#xD;#if True //判断宏是否大于0的值&#xD;printf(&#34;Hello, World!\n&#34;);&#xD;#endif&#xD;//#undef命令取消一个先前已定义的宏变量, 譬如一个用#define定义的变量.&#xD;#undef True&#xD;return 0;&#xD;} 关于指针和函数的指针 记录下</description>
    </item>
    <item>
      <title>linux下gcc编程07-使用linux下c库函数</title>
      <link>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_07/index.html</link>
      <pubDate>Thu, 18 Sep 2025 16:55:17 +0800</pubDate>
      <guid>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_07/index.html</guid>
      <description>一 。linux c库函数简介&#xA;linux下用于c编程的头文件 位于以下目录&#xA;/usr/local/include&#xD;/usr/lib/gcc-lib/target/version/include&#xD;/usr/target/include&#xD;/usr/include 库文件一般位于&#xA;/usr/lib或/lib或/lib64 二。常用库函数分类示例&#xA;1.文件操作库&#xA;参考linuxc常用c函数手册 文件操作篇（http://net.pku.edu.cn/~yhf/linux_c/）&#xA;#include &lt;stdio.h&gt; //包含io流的库 标准的输入和输出&#xD;#include &#34;string.h&#34;&#xD;/**&#xD;* fcntl.h，是unix标准中通用的头文件，其中包含的相关函数有 open，fcntl，shutdown，unlink，fclose等！&#xD;* 就是定义了文件操作的常量&#xD;*/&#xD;#include &lt;fcntl.h&gt;&#xD;#include &#34;stdlib.h&#34;&#xD;/**&#xD;* unistd.h 是 C 和 C++ 程序设计语言中提供对 POSIX 操作系统 API 的访问功能的头文件的名称&#xD;* unistd.h 中所定义的接口通常都是大量针对系统调用的封装（英语：wrapper functions），如 fork、pipe 以及各种 I/O 原语（read、write、close getpid() 等等）&#xD;*/&#xD;#include &#34;unistd.h&#34;&#xD;/**&#xD;* 是Unix/Linux系统的基本系统数据类型的头文件，含有size_t，time_t，pid_t等类型。&#xD;*/&#xD;#include &#34;sys/types.h&#34;&#xD;#define READ_SIZE 140&#xD;int main() {&#xD;/*-------获取当前的进程id*/&#xD;pid_t pt=getpid();//pid_t在sys/types.h中 getpid()在unistd.h中&#xD;printf(&#34;当前程序的进程id：%d\n&#34;,pt);&#xD;/*-------打开一个文件描述符*/&#xD;int fileDescp=open(&#34;c:/a1.txt&#34;,O_RDONLY);//open函数unistd中 常量O_RDONLY定义在fcntl.h&#xD;char s[READ_SIZE];&#xD;memset(s,&#39;\0&#39;,READ_SIZE);//将所有的字节初始化 \0&#xD;/*-------读取指定长度字节*/&#xD;//注意项目设置的什么字符集 读取文件时 如果文件不是该字符集就会读出乱码&#xD;read(fileDescp,s,READ_SIZE);&#xD;printf(&#34;读取字符串:%s\n&#34;,s);&#xD;/*-------读取全部数据*/&#xD;lseek(fileDescp,SEEK_SET,0);//设置从0开始读取&#xD;memset(s,&#39;\0&#39;,READ_SIZE);&#xD;while((read(fileDescp,s,READ_SIZE))&gt;0){&#xD;printf(&#34;读取到的数据 :%s\n&#34;,s);&#xD;}&#xD;/*-------关闭文件描述符*/&#xD;close(fileDescp);&#xD;/*-------读取全部数据*/&#xD;//创建一个文件指定权限 权限数字参考 http://www.runoob.com/linux/linux-file-attr-permission.html&#xD;int fd1 = creat(&#34;c:/test.log&#34;,777);&#xD;write(fd1, s, strlen(s));&#xD;close(fd1);&#xD;//getchar();&#xD;//return 0;&#xD;} 2.进程操作库</description>
    </item>
    <item>
      <title>linux下gcc编程08-编译linux内核</title>
      <link>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_08/index.html</link>
      <pubDate>Thu, 18 Sep 2025 16:55:17 +0800</pubDate>
      <guid>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_08/index.html</guid>
      <description>一。 linux内核简介 Linux系统一般有4个主要部分：&#xA;内核、shell、文件系统和应用程序。内核、shell和文件系统一起形成了基本的操作系统结构，它们使得用户可以运行程序、管理文件并使用系统。&#xA;linux内核 内核是操作系统的核心，具有很多最基本功能，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。&#xA;Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。如图：&#xA;**系统调用接口：**SCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 ./linux/kernel 中您可以找到 SCI 的实现，并在 ./linux/arch 中找到依赖于体系结构的部分。&#xA;**1. 内存管理 ** 对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的物理内存满足应用程序对内存的大需求量，Linux 采用了称为“虚拟内存”的内存管理方式。Linux 将内存划分为容易处理的“内存页”（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。&#xA;不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。 为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。&#xA;** 2 .进程管理** ** 进程实际是某特定应用程序的一个运行实体**。在 Linux 系统中，能够同时运行多个进程，Linux 通过在短的时间间隔内轮流运行这些进程而实现“多任务”。这一短的时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度” ，完成调度的程序称为调度程序。&#xA;进程调度控制进程对CPU的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待CPU资源的进程，如果某个进程在等待其它资源，则该进程是不可运行进程。Linux使用了比较简单的基于优先级的进程调度算法选择新的进程。 通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且只能由这一进程访问，这样，操作系统避免了进程之间的互相干扰以及“坏”程序对系统可能造成的危害。 为了完成某特定任务，有时需要综合两个程序的功能，例如一个程序输出文本，而另一个程序对文本进行排序。为此，操作系统还提供进程间的通讯机制来帮助完成这样的任务。Linux 中常见的进程间通讯机制有信号、管道、共享内存、信号量和套接字等。 </description>
    </item>
    <item>
      <title>linux下gcc编程09-编写内核helloworld模块</title>
      <link>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_09/index.html</link>
      <pubDate>Thu, 18 Sep 2025 16:55:17 +0800</pubDate>
      <guid>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_09/index.html</guid>
      <description>一。内核动态模块介绍 Linux内核给开发者提供了灵活的模块加载方式，开发者可根据需要适当地选择静态或动态的方式将模块加入内核当中。静态加载的时候我们只需将驱动文件添加到对应的文件夹中并修改相应的Makefile和Kconfig即可，但是通过动态加载模块的方式，如果只是编译一个小的驱动文件而对内核大动干戈，那样编译的时间不仅长而且修改内核配置文件也是一件多余的工作。那么我们是否可以在不修改内核的前提下单独编译它是如何编译内核的呢？下面我们就通过分析它的Makefile入手简单介绍一个编译驱动（模块）文件的新方法。&#xA;动态模块生成文件后缀名为 *.ko&#xA;内核模块的相关操作&#xA;加载内核模块：insmod 卸载内核模块：rmmod 查看内核模块：lsmod 二。动态模块helloworld开发 本人习惯于使用开发工具强大的代码补全功能 觉得效率会更高 所以我这里使用clion开发 完成后拷贝到linux编译&#xA;clion开发环境配置&#xA;主要使用clion的提示 下载内核的源代码解压 找到include目录 接下来新建一个 c的库项目 里面有 CMakeLists.txt添加引入头文件 添加include_directories后 写代码依然是没有提示的 需要重新加载一个cmake Header Search PAths就有了新包含的头文件了 接下来新建一个hello.c 写代码就有提示拉 出错可以不管 反正window编译不了的&#xA;#include &lt;linux/init.h&gt;&#xD;#include &lt;linux/module.h&gt;&#xD;MODULE_LICENSE(&#34;GPL&#34;);&#xD;static void hello_init(){&#xD;printk(KERN_INFO&#34;***********hello world init&#34;);&#xD;}&#xD;static void hello_exit(){&#xD;printk(KERN_INFO&#34;***********hello world exit&#34;);&#xD;}&#xD;module_init(hello_init);&#xD;module_exit(hello_exit); 拷贝到linux某个目录新建 Makefile（不能使用小写的makefile）</description>
    </item>
    <item>
      <title>linux下gcc编程10-clion编译调试nginx</title>
      <link>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_10/index.html</link>
      <pubDate>Thu, 18 Sep 2025 16:55:17 +0800</pubDate>
      <guid>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_10/index.html</guid>
      <description>@[toc]&#xA;1。clion简介 CLion是Jetbrains公司旗下新推出的一款专为开发C/C++所设计的跨平台IDE，它是以IntelliJ为基础设计的，同时还包含了许多智能功能来提高开发人员的生产力。&#xA;同样支持python哦，相信使用过IntelliJ idea开发过java的盆友都很清楚该IDE的强大，所以做为Jetbrains旗下的c/c++开发工具CLion同样包含了许多智能功能来提高开发人员的生产力，提高开发人员的工作效率&#xA;1.1 clion安装 1.1.1 centos clion内置使用cmake来管理编译c/c++项目，linux环境可以先按照开发工具包&#xA;yum groupinstall Development Tools window请安装Cygwin 和MinGW，window安装教程参考其他博客。 下载你想要任何版本的clion，下载地址 下载tar.gz版本服务器解压：&#xA;tar -zxvf CLion-2019.2.1.tar.gz 假设解压地址：/soft/clion-2019.2.1，可执行文件位于：/soft/clion-2019.2.1/bin/clion.sh 桌面新建一个快捷方式 ，如桌面新建一个clion.desktop 内容:&#xA;[Desktop Entry]&#xD;Name=clion&#xD;Exec=/soft/clion-2019.2.1/bin/clion.sh&#xD;Type=Application&#xD;Icon=/soft/clion-2019.2.1/bin/clion.png&#xD;Terminal=false 左面会自动生成一个图片图标，点击后自动启动clion 1.1.1 win10 clion安装通centos一致，解压即可使用，linux本身不支持gcc和linux命令需要模拟环境。&#xA;1.1.1.1 cygwin安装 linux支持两款模拟linux编译环境，cygwin和mingw,比较两个差异。 1、从目标上说MinGW 是让Windows 用户可以用上GNU 工具，比如GCC。Cygwin 提供完整的类Unix 环境，Windows 用户不仅可以使用GNU 工具，理论上Linux 上的程序只要用Cygwin 重新编译，就可以在Windows 上运行。 2、从能力上说如果程序只用到C/C++ 标准库，可以用MinGW 或Cygwin 编译。如果程序还用到了POSIX API，则只能用Cygwin 编译。 3、从依赖上说程序经MinGW 编译后可以直接在Windows 上面运行。程序经Cygwin 编译后运行，需要依赖安装时附带的cygwin1.dll。&#xA;并且cygwin是个完全模拟unix，unix相关库都可以直接通过管理工具下载安装，如gcc，pcre，zlib，无需重复编译。 安装包下载：https://cygwin.com/install.html，64位管理工具 点击安装工具，步骤中选择163或者aliyun私服 对于新手来说，需安装Base，Devel，Libs，Net，System，Utils几个模块</description>
    </item>
    <item>
      <title>linux下gcc编程11-window下clion编译调试nginx&#43;集成lua-nginx-module&#43;安装开源x-waf</title>
      <link>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_11/index.html</link>
      <pubDate>Thu, 18 Sep 2025 16:55:17 +0800</pubDate>
      <guid>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_11/index.html</guid>
      <description>nginx模块 nginx作为项目的7层代理入口，对于http请求的过滤，如sql注入，xss攻击等过滤功能较弱，研究了下开源的一些waf，完全开源的https://github.com/xsec-lab/x-waf，利用lua来过滤请求，同时拥有一个管理控制台，添加规则和代理，但使用过程中，缺少文档，碰到一些问题，需要调试和增强，促使用window编译通过源代码lua和使用x-waf。&#xA;lua-nginx-module模块 ngx_ http_lua_ module-将 Lua 的强大功能嵌入到 Nginx HTTP 服务器中。这个模块是 OpenResty 的核心组件，如果您正在使用这个模块，那么您实际上就是在使用 OpenResty。这个模块没有随 Nginx 源代码一起发布。这是 OpenResty 的一个核心组件，如果你正在使用这个模块，那么你实际上是在使用 OpenResty:)&#xA;x-waf X-WAF是一款适用中、小企业的云WAF系统，让中、小企业也可以非常方便地拥有自己的免费云WAF。 项目已经5年未更新，可以作为研究目的，可以通过安全攻击过程分析，自行拓展规则。 文档地址：https://github.com/xsec-lab/x-waf&#xA;主要特性&#xA;支持对常见WEB攻击的防御，如sql注入、xss、路径穿越，阻断扫描器的扫描等 对持对CC攻击的防御 waf为反向模式，后端保护的服务器可直接用内网IP，不需暴露在公网中 支持IP、URL、Referer、User-Agent、Get、Post、Cookies参数型的防御策略 安装、部署与维护非常简单 支持在线管理waf规则 支持在线管理后端服务器 多台waf的配置可自动同步 跨平台，支持在linux、unix、mac和windows操作系统中部署 x-waf安装 linux安装 安装openresty 下载对应系统的安装包 http://openresty.org/cn/linux-packages.html debian系统安装参考：http://openresty.org/cn/linux-packages.html#debian 或者通过源码安装参考： http://openresty.org/cn/installation.html 安装完假设目录为： –prefix=/usr/local/openresty&#xA;安装x-waf 克隆x-waf到/usr/local/openresty/nginx/conf目录&#xA;cd /usr/local/openresty/nginx/conf &amp;&amp; git clone https://github.com/xsec-lab/x-waf 下载下来是一个x-waf 的文件夹，里面的 nginx_conf/nginx.conf 文件是一个配置好了lua和x-waf规则目录的模板文件，可以拷贝到 /usr/local/openresty/nginx/conf/nginx.conf 直接覆盖原有openresty的配置文件&#xA;cp /usr/local/openresty/nginx/conf/x-waf/nginx_conf/nginx.conf /usr/local/openresty/nginx/conf/nginx.conf 作者的代码里面url白名单部分有个错误，需要修正一下，否则会因为找不到url白名单文件，而导致白名单失效&#xA;vi /usr/local/openresty/nginx/conf/x-waf/waf.lua&#xA;找到 writeurl.rule，替换为 whiteUrl.rule 建立虚拟主机配置文件目录（这里主要是nginx.conf里include了，管理后台生成的代理文件目录）</description>
    </item>
    <item>
      <title>linux下gcc编程12-window下clion编译调试redis7.0</title>
      <link>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_12/index.html</link>
      <pubDate>Thu, 18 Sep 2025 16:55:17 +0800</pubDate>
      <guid>https://jiaozi789.github.io/docs/programming/languages/gcc/linuxgcc_12/index.html</guid>
      <description>redis介绍 Redis 通常被称为数据结构服务器。这意味着 Redis 通过一组命令提供对可变数据结构的访问，这些命令使用具有 TCP 套接字和简单协议的服务器-客户机模型发送。因此，不同的进程可以以共享的方式查询和修改相同的数据结构。&#xA;在 Redis 中实现的数据结构具有一些特殊属性:&#xA;注意将它们存储在磁盘上，即使它们总是被提供并修改到服务器内存中。这意味着 Redis 是快速的，但它也是非易失性的。 数据结构的实现强调了内存效率，因此与使用高级语言建模的相同数据结构相比，Redis 内部的数据结构可能会使用更少的内存 提供了一些在数据库中自然可以找到的特性，比如复制、可调的持久性级别、集群和高可用性。 另一个很好的例子是将 Redis 视为 memcached 的一个更复杂的版本，其中的操作不仅仅是 SET 和 GET，还包括处理复杂数据类型(如 List、 Set、有序数据结构等)的操作。&#xA;如果你想知道更多，这是一个选定的起点列表:&#xA;Redis 数据类型简介 https://redis.io/topics/data-types-intro 直接在浏览器中尝试 Redis https://try.redis.io Redis 命令的完整列表 https://redis.io/commands 官方 Redis 文档中还有更多内容 https://redis.io/documentation window下编译redis window编译redis的目的主要是用于在clion下调试redis，方便代码阅读。 安装cygwin环境：参考:nginx编译教程中安装cygwin章节&#xA;下载redis7.0代码：&#xA;git clone -b 7.0 https://github.com/redis/redis.git 打开Cygwin64 Terminal，执行命令：make。&#xA;make&#xD;cd src &amp;&amp; make all&#xD;make[1]: Entering directory &#39;/cygdrive/d/code1/redis-7.0/src&#39;&#xD;CC Makefile.dep 编译过程中会报错&#xA;debug.c:1759:5: error: unknown type name ‘Dl_info’ 查看src/debug.c有代码如下：&#xA;#include &lt;dlfcn.h&gt; 找到cygwin安装目录下的usr\include\dlfcn.h,有一段代码</description>
    </item>
  </channel>
</rss>
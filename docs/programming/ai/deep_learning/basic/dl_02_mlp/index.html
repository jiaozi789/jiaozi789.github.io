<!DOCTYPE html>
<html lang="zh" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.150.0">
    <meta name="generator" content="Relearn 8.0.1+b23cf6629eada0c2802f34ae4012e04343497862">
    <meta name="description" content="神经网络 简介 神经网络是一种基于生物神经系统结构和功能特点而设计的人工神经网络模型，具有很强的自适应性和非线性映射能力。神经网络由多个神经元（或称节点）组成，这些神经元通过连接权重相互连接，构成多层的网络结构。每个神经元接收到来自其它神经元的信号，并将这些信号加权线性组合后通过激活函数进行非线性转换，最终输出给下一层神经元或输出层。
学习机器学习后，学习神经网络可以帮助你更深入地理解模式识别和人工智能领域的基础知识。神经网络在很多领域都有广泛的应用，例如计算机视觉、自然语言处理、语音识别等。学习神经网络可以让你掌握这些领域中最前沿的技术，并且能够应用这些技术来解决具体的问题。同时，神经网络的学习方法和算法也是机器学习的重要组成部分，学习神经网络可以帮助你更好地理解机器学习的原理和技术，从而更好地应用机器学习来解决实际问题。
学习路径 如果你已经学过机器学习，那么开始学习神经网络，可以从多层感知器（Multilayer Perceptron，简称 MLP）神经网络入手。 MLP 是最基本的神经网络模型之一，它的结构比较简单，易于理解和实现，同时又有很好的可扩展性和通用性，可以应用于分类、回归等多种任务。学习 MLP 之后，你可以进一步学习卷积神经网络（Convolutional Neural Networks，简称 CNN）和循环神经网络（Recurrent Neural Networks，简称 RNN），它们分别用于计算机视觉和自然语言处理等特定领域的问题。总之，建议先从 MLP 入手，逐渐深入学习其他类型的神经网络。
分类 神经网络可以分为多种不同的类型，下面列举一些常见的神经网络类型：
前馈神经网络（Feedforward Neural Network）：前馈神经网络是最基本的神经网络类型，也是深度学习中最常见的神经网络类型。它由若干个神经元按照一定的层次结构组成，每个神经元接收上一层的输出，产生本层的输出，从而实现信息的传递和处理。
卷积神经网络（Convolutional Neural Network）：卷积神经网络是一种专门用于图像处理和计算机视觉任务的神经网络类型。它通过卷积和池化等操作，可以提取图像中的特征，从而实现图像分类、目标检测、图像分割等任务。
循环神经网络（Recurrent Neural Network）：循环神经网络是一种能够处理序列数据的神经网络类型。它通过记忆单元和门控机制等方式，可以处理任意长度的序列数据，从而实现自然语言处理、语音识别等任务。
自编码器（Autoencoder）：自编码器是一种无监督学习的神经网络类型，它的目标是将输入数据进行压缩和解压缩，从而实现特征提取和降维等任务。
深度置信网络（Deep Belief Network）：深度置信网络是一种由多个受限玻尔兹曼机组成的神经网络类型。它可以通过逐层贪心预训练和微调等方式，实现高效的特征学习和分类任务。
除了以上列举的几种神经网络类型，还有众多其他的神经网络类型，如反向传播神经网络、Hopfield网络、Boltzmann机等。不同的神经网络类型适用于不同的任务和数据类型，需要根据具体的问题选择合适的神经网络类型。
多层感知器（MLP） MLP神经网络属于前馈神经网络（Feedforward Neural Network）的一种。在网络训练过程中，需要通过反向传播算法计算梯度，将误差从输出层反向传播回输入层，用于更新网络参数。这个过程中需要使用反向传播算法来计算梯度，并且在某些类型的神经网络中，例如循环神经网络（RNN），也存在反馈回路。除了MLP，其他常见的前馈神经网络包括卷积神经网络（CNN）和循环神经网络（RNN）等。
神经网络认识 我们以一个简单的例子来认识神经网络，只是为了理解其中的一些概念。 我们已知四个数据点(1,1)(-1,1)(-1,-1)(1,-1)，这四个点分别对应I~IV象限（也就是数据属于的类别），如果这时候给我们一个新的坐标点（比如(2,2)），那么它应该属于哪个象限呢？（没错，当然是第I象限，但我们的任务是要让机器知道，机器不知道有象限这个东西啊，他只能根据历史数据的经验推断），如果机器只是知道一堆数据 比如(-2,3)属于2象限，机器就需要通过这些数据总结出一个特征，这个特征可能就是根据x和y坐标的正负来判断象限了。 两层神经网络 这里我们构建一个两层神经网络，理论上两层神经网络已经可以拟合任意函数。这个神经网络的结构如下图： 首先我们去掉途中难懂的东西">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="深度学习02-神经网络(MLP多层感知器) :: liaomin416100569博客">
    <meta name="twitter:description" content="神经网络 简介 神经网络是一种基于生物神经系统结构和功能特点而设计的人工神经网络模型，具有很强的自适应性和非线性映射能力。神经网络由多个神经元（或称节点）组成，这些神经元通过连接权重相互连接，构成多层的网络结构。每个神经元接收到来自其它神经元的信号，并将这些信号加权线性组合后通过激活函数进行非线性转换，最终输出给下一层神经元或输出层。
学习机器学习后，学习神经网络可以帮助你更深入地理解模式识别和人工智能领域的基础知识。神经网络在很多领域都有广泛的应用，例如计算机视觉、自然语言处理、语音识别等。学习神经网络可以让你掌握这些领域中最前沿的技术，并且能够应用这些技术来解决具体的问题。同时，神经网络的学习方法和算法也是机器学习的重要组成部分，学习神经网络可以帮助你更好地理解机器学习的原理和技术，从而更好地应用机器学习来解决实际问题。
学习路径 如果你已经学过机器学习，那么开始学习神经网络，可以从多层感知器（Multilayer Perceptron，简称 MLP）神经网络入手。 MLP 是最基本的神经网络模型之一，它的结构比较简单，易于理解和实现，同时又有很好的可扩展性和通用性，可以应用于分类、回归等多种任务。学习 MLP 之后，你可以进一步学习卷积神经网络（Convolutional Neural Networks，简称 CNN）和循环神经网络（Recurrent Neural Networks，简称 RNN），它们分别用于计算机视觉和自然语言处理等特定领域的问题。总之，建议先从 MLP 入手，逐渐深入学习其他类型的神经网络。
分类 神经网络可以分为多种不同的类型，下面列举一些常见的神经网络类型：
前馈神经网络（Feedforward Neural Network）：前馈神经网络是最基本的神经网络类型，也是深度学习中最常见的神经网络类型。它由若干个神经元按照一定的层次结构组成，每个神经元接收上一层的输出，产生本层的输出，从而实现信息的传递和处理。
卷积神经网络（Convolutional Neural Network）：卷积神经网络是一种专门用于图像处理和计算机视觉任务的神经网络类型。它通过卷积和池化等操作，可以提取图像中的特征，从而实现图像分类、目标检测、图像分割等任务。
循环神经网络（Recurrent Neural Network）：循环神经网络是一种能够处理序列数据的神经网络类型。它通过记忆单元和门控机制等方式，可以处理任意长度的序列数据，从而实现自然语言处理、语音识别等任务。
自编码器（Autoencoder）：自编码器是一种无监督学习的神经网络类型，它的目标是将输入数据进行压缩和解压缩，从而实现特征提取和降维等任务。
深度置信网络（Deep Belief Network）：深度置信网络是一种由多个受限玻尔兹曼机组成的神经网络类型。它可以通过逐层贪心预训练和微调等方式，实现高效的特征学习和分类任务。
除了以上列举的几种神经网络类型，还有众多其他的神经网络类型，如反向传播神经网络、Hopfield网络、Boltzmann机等。不同的神经网络类型适用于不同的任务和数据类型，需要根据具体的问题选择合适的神经网络类型。
多层感知器（MLP） MLP神经网络属于前馈神经网络（Feedforward Neural Network）的一种。在网络训练过程中，需要通过反向传播算法计算梯度，将误差从输出层反向传播回输入层，用于更新网络参数。这个过程中需要使用反向传播算法来计算梯度，并且在某些类型的神经网络中，例如循环神经网络（RNN），也存在反馈回路。除了MLP，其他常见的前馈神经网络包括卷积神经网络（CNN）和循环神经网络（RNN）等。
神经网络认识 我们以一个简单的例子来认识神经网络，只是为了理解其中的一些概念。 我们已知四个数据点(1,1)(-1,1)(-1,-1)(1,-1)，这四个点分别对应I~IV象限（也就是数据属于的类别），如果这时候给我们一个新的坐标点（比如(2,2)），那么它应该属于哪个象限呢？（没错，当然是第I象限，但我们的任务是要让机器知道，机器不知道有象限这个东西啊，他只能根据历史数据的经验推断），如果机器只是知道一堆数据 比如(-2,3)属于2象限，机器就需要通过这些数据总结出一个特征，这个特征可能就是根据x和y坐标的正负来判断象限了。 两层神经网络 这里我们构建一个两层神经网络，理论上两层神经网络已经可以拟合任意函数。这个神经网络的结构如下图： 首先我们去掉途中难懂的东西">
    <meta property="og:url" content="https://jiaozi789.github.io/docs/programming/ai/deep_learning/basic/dl_02_mlp/index.html">
    <meta property="og:site_name" content="liaomin416100569博客">
    <meta property="og:title" content="深度学习02-神经网络(MLP多层感知器) :: liaomin416100569博客">
    <meta property="og:description" content="神经网络 简介 神经网络是一种基于生物神经系统结构和功能特点而设计的人工神经网络模型，具有很强的自适应性和非线性映射能力。神经网络由多个神经元（或称节点）组成，这些神经元通过连接权重相互连接，构成多层的网络结构。每个神经元接收到来自其它神经元的信号，并将这些信号加权线性组合后通过激活函数进行非线性转换，最终输出给下一层神经元或输出层。
学习机器学习后，学习神经网络可以帮助你更深入地理解模式识别和人工智能领域的基础知识。神经网络在很多领域都有广泛的应用，例如计算机视觉、自然语言处理、语音识别等。学习神经网络可以让你掌握这些领域中最前沿的技术，并且能够应用这些技术来解决具体的问题。同时，神经网络的学习方法和算法也是机器学习的重要组成部分，学习神经网络可以帮助你更好地理解机器学习的原理和技术，从而更好地应用机器学习来解决实际问题。
学习路径 如果你已经学过机器学习，那么开始学习神经网络，可以从多层感知器（Multilayer Perceptron，简称 MLP）神经网络入手。 MLP 是最基本的神经网络模型之一，它的结构比较简单，易于理解和实现，同时又有很好的可扩展性和通用性，可以应用于分类、回归等多种任务。学习 MLP 之后，你可以进一步学习卷积神经网络（Convolutional Neural Networks，简称 CNN）和循环神经网络（Recurrent Neural Networks，简称 RNN），它们分别用于计算机视觉和自然语言处理等特定领域的问题。总之，建议先从 MLP 入手，逐渐深入学习其他类型的神经网络。
分类 神经网络可以分为多种不同的类型，下面列举一些常见的神经网络类型：
前馈神经网络（Feedforward Neural Network）：前馈神经网络是最基本的神经网络类型，也是深度学习中最常见的神经网络类型。它由若干个神经元按照一定的层次结构组成，每个神经元接收上一层的输出，产生本层的输出，从而实现信息的传递和处理。
卷积神经网络（Convolutional Neural Network）：卷积神经网络是一种专门用于图像处理和计算机视觉任务的神经网络类型。它通过卷积和池化等操作，可以提取图像中的特征，从而实现图像分类、目标检测、图像分割等任务。
循环神经网络（Recurrent Neural Network）：循环神经网络是一种能够处理序列数据的神经网络类型。它通过记忆单元和门控机制等方式，可以处理任意长度的序列数据，从而实现自然语言处理、语音识别等任务。
自编码器（Autoencoder）：自编码器是一种无监督学习的神经网络类型，它的目标是将输入数据进行压缩和解压缩，从而实现特征提取和降维等任务。
深度置信网络（Deep Belief Network）：深度置信网络是一种由多个受限玻尔兹曼机组成的神经网络类型。它可以通过逐层贪心预训练和微调等方式，实现高效的特征学习和分类任务。
除了以上列举的几种神经网络类型，还有众多其他的神经网络类型，如反向传播神经网络、Hopfield网络、Boltzmann机等。不同的神经网络类型适用于不同的任务和数据类型，需要根据具体的问题选择合适的神经网络类型。
多层感知器（MLP） MLP神经网络属于前馈神经网络（Feedforward Neural Network）的一种。在网络训练过程中，需要通过反向传播算法计算梯度，将误差从输出层反向传播回输入层，用于更新网络参数。这个过程中需要使用反向传播算法来计算梯度，并且在某些类型的神经网络中，例如循环神经网络（RNN），也存在反馈回路。除了MLP，其他常见的前馈神经网络包括卷积神经网络（CNN）和循环神经网络（RNN）等。
神经网络认识 我们以一个简单的例子来认识神经网络，只是为了理解其中的一些概念。 我们已知四个数据点(1,1)(-1,1)(-1,-1)(1,-1)，这四个点分别对应I~IV象限（也就是数据属于的类别），如果这时候给我们一个新的坐标点（比如(2,2)），那么它应该属于哪个象限呢？（没错，当然是第I象限，但我们的任务是要让机器知道，机器不知道有象限这个东西啊，他只能根据历史数据的经验推断），如果机器只是知道一堆数据 比如(-2,3)属于2象限，机器就需要通过这些数据总结出一个特征，这个特征可能就是根据x和y坐标的正负来判断象限了。 两层神经网络 这里我们构建一个两层神经网络，理论上两层神经网络已经可以拟合任意函数。这个神经网络的结构如下图： 首先我们去掉途中难懂的东西">
    <meta property="og:locale" content="zh">
    <meta property="og:type" content="article">
    <meta property="article:section" content="编程开发">
    <meta property="article:published_time" content="2025-09-18T16:55:17+08:00">
    <meta property="article:modified_time" content="2025-09-18T16:55:17+08:00">
    <meta itemprop="name" content="深度学习02-神经网络(MLP多层感知器) :: liaomin416100569博客">
    <meta itemprop="description" content="神经网络 简介 神经网络是一种基于生物神经系统结构和功能特点而设计的人工神经网络模型，具有很强的自适应性和非线性映射能力。神经网络由多个神经元（或称节点）组成，这些神经元通过连接权重相互连接，构成多层的网络结构。每个神经元接收到来自其它神经元的信号，并将这些信号加权线性组合后通过激活函数进行非线性转换，最终输出给下一层神经元或输出层。
学习机器学习后，学习神经网络可以帮助你更深入地理解模式识别和人工智能领域的基础知识。神经网络在很多领域都有广泛的应用，例如计算机视觉、自然语言处理、语音识别等。学习神经网络可以让你掌握这些领域中最前沿的技术，并且能够应用这些技术来解决具体的问题。同时，神经网络的学习方法和算法也是机器学习的重要组成部分，学习神经网络可以帮助你更好地理解机器学习的原理和技术，从而更好地应用机器学习来解决实际问题。
学习路径 如果你已经学过机器学习，那么开始学习神经网络，可以从多层感知器（Multilayer Perceptron，简称 MLP）神经网络入手。 MLP 是最基本的神经网络模型之一，它的结构比较简单，易于理解和实现，同时又有很好的可扩展性和通用性，可以应用于分类、回归等多种任务。学习 MLP 之后，你可以进一步学习卷积神经网络（Convolutional Neural Networks，简称 CNN）和循环神经网络（Recurrent Neural Networks，简称 RNN），它们分别用于计算机视觉和自然语言处理等特定领域的问题。总之，建议先从 MLP 入手，逐渐深入学习其他类型的神经网络。
分类 神经网络可以分为多种不同的类型，下面列举一些常见的神经网络类型：
前馈神经网络（Feedforward Neural Network）：前馈神经网络是最基本的神经网络类型，也是深度学习中最常见的神经网络类型。它由若干个神经元按照一定的层次结构组成，每个神经元接收上一层的输出，产生本层的输出，从而实现信息的传递和处理。
卷积神经网络（Convolutional Neural Network）：卷积神经网络是一种专门用于图像处理和计算机视觉任务的神经网络类型。它通过卷积和池化等操作，可以提取图像中的特征，从而实现图像分类、目标检测、图像分割等任务。
循环神经网络（Recurrent Neural Network）：循环神经网络是一种能够处理序列数据的神经网络类型。它通过记忆单元和门控机制等方式，可以处理任意长度的序列数据，从而实现自然语言处理、语音识别等任务。
自编码器（Autoencoder）：自编码器是一种无监督学习的神经网络类型，它的目标是将输入数据进行压缩和解压缩，从而实现特征提取和降维等任务。
深度置信网络（Deep Belief Network）：深度置信网络是一种由多个受限玻尔兹曼机组成的神经网络类型。它可以通过逐层贪心预训练和微调等方式，实现高效的特征学习和分类任务。
除了以上列举的几种神经网络类型，还有众多其他的神经网络类型，如反向传播神经网络、Hopfield网络、Boltzmann机等。不同的神经网络类型适用于不同的任务和数据类型，需要根据具体的问题选择合适的神经网络类型。
多层感知器（MLP） MLP神经网络属于前馈神经网络（Feedforward Neural Network）的一种。在网络训练过程中，需要通过反向传播算法计算梯度，将误差从输出层反向传播回输入层，用于更新网络参数。这个过程中需要使用反向传播算法来计算梯度，并且在某些类型的神经网络中，例如循环神经网络（RNN），也存在反馈回路。除了MLP，其他常见的前馈神经网络包括卷积神经网络（CNN）和循环神经网络（RNN）等。
神经网络认识 我们以一个简单的例子来认识神经网络，只是为了理解其中的一些概念。 我们已知四个数据点(1,1)(-1,1)(-1,-1)(1,-1)，这四个点分别对应I~IV象限（也就是数据属于的类别），如果这时候给我们一个新的坐标点（比如(2,2)），那么它应该属于哪个象限呢？（没错，当然是第I象限，但我们的任务是要让机器知道，机器不知道有象限这个东西啊，他只能根据历史数据的经验推断），如果机器只是知道一堆数据 比如(-2,3)属于2象限，机器就需要通过这些数据总结出一个特征，这个特征可能就是根据x和y坐标的正负来判断象限了。 两层神经网络 这里我们构建一个两层神经网络，理论上两层神经网络已经可以拟合任意函数。这个神经网络的结构如下图： 首先我们去掉途中难懂的东西">
    <meta itemprop="datePublished" content="2025-09-18T16:55:17+08:00">
    <meta itemprop="dateModified" content="2025-09-18T16:55:17+08:00">
    <meta itemprop="wordCount" content="2049">
    <title>深度学习02-神经网络(MLP多层感知器) :: liaomin416100569博客</title>
    <link href="/docs/css/auto-complete/auto-complete.min.css?1758355652" rel="stylesheet">
    <script src="/docs/js/auto-complete/auto-complete.min.js?1758355652" defer></script>
    <script src="/docs/js/search-lunr.min.js?1758355652" defer></script>
    <script src="/docs/js/search.min.js?1758355652" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/docs/searchindex.en.js?1758355652";
    </script>
    <script src="/docs/js/lunr/lunr.min.js?1758355652" defer></script>
    <script src="/docs/js/lunr/lunr.stemmer.support.min.js?1758355652" defer></script>
    <script src="/docs/js/lunr/lunr.multi.min.js?1758355652" defer></script>
    <script src="/docs/js/lunr/lunr.zh.min.js?1758355652" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['zh'];
    </script>
    <link href="/docs/fonts/fontawesome/css/fontawesome-all.min.css?1758355652" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/docs/fonts/fontawesome/css/fontawesome-all.min.css?1758355652" rel="stylesheet"></noscript>
    <link href="/docs/css/perfect-scrollbar/perfect-scrollbar.min.css?1758355652" rel="stylesheet">
    <link href="/docs/css/theme.min.css?1758355652" rel="stylesheet">
    <link href="/docs/css/format-html.min.css?1758355652" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/programming\/ai\/deep_learning\/basic\/dl_02_mlp\/index.html';
      window.relearn.relBasePath='..\/..\/..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..\/..\/..\/..';
      window.relearn.absBaseUri='https:\/\/jiaozi789.github.io\/docs';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=false;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'auto' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/docs/css/custom.css?1758355652" rel="stylesheet">
  </head>
  <body class="mobile-support html" data-url="/docs/programming/ai/deep_learning/basic/dl_02_mlp/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#神经网络">神经网络</a>
      <ul>
        <li><a href="#简介">简介</a></li>
        <li><a href="#学习路径">学习路径</a></li>
        <li><a href="#分类">分类</a></li>
      </ul>
    </li>
    <li><a href="#多层感知器mlp">多层感知器（MLP）</a>
      <ul>
        <li><a href="#神经网络认识">神经网络认识</a></li>
        <li><a href="#两层神经网络">两层神经网络</a>
          <ul>
            <li><a href="#输入层">输入层</a></li>
            <li><a href="#从输入层到隐藏层">从输入层到隐藏层</a></li>
            <li><a href="#从隐藏层到输出层">从隐藏层到输出层</a></li>
            <li><a href="#激活层">激活层</a></li>
            <li><a href="#输出的正规化">输出的正规化</a></li>
            <li><a href="#如何衡量输出的好坏">如何衡量输出的好坏</a></li>
            <li></li>
            <li><a href="#反向传播与参数优化">反向传播与参数优化</a></li>
            <li><a href="#过拟合">过拟合</a></li>
          </ul>
        </li>
        <li><a href="#bp算法推导">BP算法推导</a>
          <ul>
            <li><a href="#定义">定义</a></li>
            <li><a href="#算法讲解">算法讲解</a>
              <ul>
                <li><a href="#前向传播">前向传播</a></li>
                <li><a href="#反向传播">反向传播</a></li>
              </ul>
            </li>
            <li><a href="#具体实例">具体实例</a></li>
          </ul>
        </li>
        <li><a href="#tensorflow实战">tensorflow实战</a>
          <ul>
            <li><a href="#加载数据集">加载数据集</a></li>
            <li><a href="#数据预处理">数据预处理</a>
              <ul>
                <li><a href="#one-host编码">one-host编码</a></li>
                <li><a href="#kerasutilsto_categorical">keras.utils.to_categorical()</a></li>
              </ul>
            </li>
            <li><a href="#构造多层感知器模型">构造多层感知器模型</a>
              <ul>
                <li><a href="#tfkerassequential">tf.keras.Sequential</a></li>
                <li><a href="#keraslayersdense">keras.layers.Dense</a></li>
                <li><a href="#keraslayersdropout">keras.layers.Dropout</a></li>
                <li><a href="#keraslayers其他">keras.layers.其他</a></li>
              </ul>
            </li>
            <li><a href="#模型编译">模型编译</a>
              <ul>
                <li><a href="#优化器">优化器</a></li>
                <li><a href="#损失函数">损失函数</a></li>
                <li><a href="#评价指标">评价指标</a></li>
              </ul>
            </li>
            <li><a href="#模型训练">模型训练</a></li>
            <li><a href="#模型评估">模型评估</a></li>
            <li><a href="#模型预测">模型预测</a></li>
            <li><a href="#完整运行">完整运行</a></li>
            <li><a href="#模型保存和加载">模型保存和加载</a></li>
            <li><a href="#绘制ui手写数字识别">绘制ui手写数字识别</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/docs/index.html"><span itemprop="name">liaomin416100569博客</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/docs/programming/index.html"><span itemprop="name">编程开发</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/docs/programming/ai/index.html"><span itemprop="name">人工智能</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/docs/programming/ai/deep_learning/index.html"><span itemprop="name">深度学习</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/docs/programming/ai/deep_learning/basic/index.html"><span itemprop="name">深度基础</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">深度学习02-神经网络(MLP多层感知器)</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/docs/programming/ai/deep_learning/basic/index.html" title="深度基础 (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/docs/programming/ai/deep_learning/frameworks/index.html" title="框架学习 (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable programming" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="深度学习02-神经网络mlp多层感知器">深度学习02-神经网络(MLP多层感知器)</h1>

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']]
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

<h1 id="神经网络">神经网络</h1>
<h2 id="简介">简介</h2>
<p>神经网络是一种基于生物神经系统结构和功能特点而设计的人工神经网络模型，具有很强的自适应性和非线性映射能力。神经网络由多个神经元（或称节点）组成，这些神经元通过连接权重相互连接，构成多层的网络结构。每个神经元接收到来自其它神经元的信号，并将这些信号加权线性组合后通过激活函数进行非线性转换，最终输出给下一层神经元或输出层。</p>
<p>学习机器学习后，学习神经网络可以帮助你更深入地理解模式识别和人工智能领域的基础知识。神经网络在很多领域都有广泛的应用，例如计算机视觉、自然语言处理、语音识别等。学习神经网络可以让你掌握这些领域中最前沿的技术，并且能够应用这些技术来解决具体的问题。同时，神经网络的学习方法和算法也是机器学习的重要组成部分，学习神经网络可以帮助你更好地理解机器学习的原理和技术，从而更好地应用机器学习来解决实际问题。</p>
<h2 id="学习路径">学习路径</h2>
<p>如果你已经学过机器学习，那么开始学习神经网络，可以从多层感知器（Multilayer Perceptron，简称 MLP）神经网络入手。 MLP 是最基本的神经网络模型之一，它的结构比较简单，易于理解和实现，同时又有很好的可扩展性和通用性，可以应用于分类、回归等多种任务。学习 MLP 之后，你可以进一步学习卷积神经网络（Convolutional Neural Networks，简称 CNN）和循环神经网络（Recurrent Neural Networks，简称 RNN），它们分别用于计算机视觉和自然语言处理等特定领域的问题。总之，建议先从 MLP 入手，逐渐深入学习其他类型的神经网络。</p>
<h2 id="分类">分类</h2>
<p>神经网络可以分为多种不同的类型，下面列举一些常见的神经网络类型：</p>
<ol>
<li>
<p>前馈神经网络（Feedforward Neural Network）：前馈神经网络是最基本的神经网络类型，也是深度学习中最常见的神经网络类型。它由若干个神经元按照一定的层次结构组成，每个神经元接收上一层的输出，产生本层的输出，从而实现信息的传递和处理。</p>
</li>
<li>
<p>卷积神经网络（Convolutional Neural Network）：卷积神经网络是一种专门用于图像处理和计算机视觉任务的神经网络类型。它通过卷积和池化等操作，可以提取图像中的特征，从而实现图像分类、目标检测、图像分割等任务。</p>
</li>
<li>
<p>循环神经网络（Recurrent Neural Network）：循环神经网络是一种能够处理序列数据的神经网络类型。它通过记忆单元和门控机制等方式，可以处理任意长度的序列数据，从而实现自然语言处理、语音识别等任务。</p>
</li>
<li>
<p>自编码器（Autoencoder）：自编码器是一种无监督学习的神经网络类型，它的目标是将输入数据进行压缩和解压缩，从而实现特征提取和降维等任务。</p>
</li>
<li>
<p>深度置信网络（Deep Belief Network）：深度置信网络是一种由多个受限玻尔兹曼机组成的神经网络类型。它可以通过逐层贪心预训练和微调等方式，实现高效的特征学习和分类任务。</p>
</li>
</ol>
<p>除了以上列举的几种神经网络类型，还有众多其他的神经网络类型，如反向传播神经网络、Hopfield网络、Boltzmann机等。不同的神经网络类型适用于不同的任务和数据类型，需要根据具体的问题选择合适的神经网络类型。</p>
<h1 id="多层感知器mlp">多层感知器（MLP）</h1>
<p>MLP神经网络属于前馈神经网络（Feedforward Neural Network）的一种。在网络训练过程中，需要通过反向传播算法计算梯度，将误差从输出层反向传播回输入层，用于更新网络参数。这个过程中需要使用反向传播算法来计算梯度，并且在某些类型的神经网络中，例如循环神经网络（RNN），也存在反馈回路。除了MLP，其他常见的前馈神经网络包括卷积神经网络（CNN）和循环神经网络（RNN）等。</p>
<h2 id="神经网络认识">神经网络认识</h2>
<p>我们以一个简单的例子来认识神经网络，只是为了理解其中的一些概念。
我们已知四个数据点(1,1)(-1,1)(-1,-1)(1,-1)，这四个点分别对应I~IV象限（也就是数据属于的类别），如果这时候给我们一个新的坐标点（比如(2,2)），那么它应该属于哪个象限呢？（没错，当然是第I象限，但我们的任务是要让机器知道，机器不知道有象限这个东西啊，他只能根据历史数据的经验推断），如果机器只是知道一堆数据 比如(-2,3)属于2象限，机器就需要通过这些数据总结出一个特征，这个特征可能就是根据x和y坐标的正负来判断象限了。
<a href="#R-image-e1b9e72b20b2a982252370881cbdf840" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/ce0306ba6a16e1940b5dd5ea5ea7573d.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e1b9e72b20b2a982252370881cbdf840"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/ce0306ba6a16e1940b5dd5ea5ea7573d.png"></a></p>
<h2 id="两层神经网络">两层神经网络</h2>
<p>这里我们构建一个两层神经网络，理论上两层神经网络已经可以拟合任意函数。这个神经网络的结构如下图：
<a href="#R-image-11103980042ffeed4ca00f12467aaf27" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/b99f5e9c69435ed576affdf6f6b8cb44.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-11103980042ffeed4ca00f12467aaf27"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/b99f5e9c69435ed576affdf6f6b8cb44.png"></a>
首先我们去掉途中难懂的东西
<a href="#R-image-1d3aa3ef2eeb94090e30a8a6f8b5f956" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/ace7457066b3f51dbf5e87b32bb6efb2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1d3aa3ef2eeb94090e30a8a6f8b5f956"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/ace7457066b3f51dbf5e87b32bb6efb2.png"></a></p>
<h3 id="输入层">输入层</h3>
<p>在我们的例子中，输入层是坐标值，例如（1,1），这是一个包含两个元素的数组，也可以看作是一个1<em>2的矩阵。输入层的元素维度与输入量的特征息息相关，如果输入的是一张32</em>32像素的灰度图像，那么输入层的维度就是32*32。
<!-- raw HTML omitted -->因为整个神经网络的目的是为了训练出一个模型，所以输入的是历史数据，历史数据有一个确定的输出label，模型出来后，直接使用模型就可以分类出输入的数据的输出<!-- raw HTML omitted -->
这里输入的数据为:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>[
[1,1],
[-1,1],
[-1,-1],
[1,-1]
]</code></pre></div>
<h3 id="从输入层到隐藏层">从输入层到隐藏层</h3>
<p>连接输入层和隐藏层的是W1和b1。由X计算得到H十分简单，就是矩阵运算：
$H=w<em>x+b$
果你学过线性代数，对这个式子一定不陌生,可以理解为w是一个权重(权重越高，这个特征也就越重要)，b是一个偏置，如果有多个特征那么就有个w，还记得<a href="https://blog.csdn.net/liaomin416100569/article/details/130362121?spm=1001.2014.3001.5501" rel="external" target="_blank">$w^T*x$</a>。
<a href="#R-image-8c0c88d4d39ff1c5ca90ccebed9c6353" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/ace7457066b3f51dbf5e87b32bb6efb2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8c0c88d4d39ff1c5ca90ccebed9c6353"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/ace7457066b3f51dbf5e87b32bb6efb2.png"></a>
如上图中所示，在设定隐藏层为50维（也可以理解成50个神经元）之后，矩阵H的大小为（4</em>50）的矩阵。
<a href="#R-image-a8f7416244fad3940fddf859a6efa07a" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/14b2e6bdf6e5714a52f9d1ce50b289d9.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a8f7416244fad3940fddf859a6efa07a"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/14b2e6bdf6e5714a52f9d1ce50b289d9.png"></a></p>
<p>也就是说50个神经元就是一个矩阵50个特征，每一行就是他的w值，这里输入层总共两个维度，所有只有w1和w2，b值这里就不说了，假设为0
<a href="#R-image-cdfc6a158351893d1132cb2f79d65ad4" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/84cae8864c216fd1cd84bdf7b8cc2671.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cdfc6a158351893d1132cb2f79d65ad4"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/84cae8864c216fd1cd84bdf7b8cc2671.png"></a>
这里我们可以简化最终得到4*50的意义
<a href="#R-image-6913febe25fc735790bb1b985edfc91c" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/3d0b86b1f1ae2fe3ee9cc8048ee4d0fd.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6913febe25fc735790bb1b985edfc91c"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/3d0b86b1f1ae2fe3ee9cc8048ee4d0fd.png"></a></p>
<h3 id="从隐藏层到输出层">从隐藏层到输出层</h3>
<p>连接隐藏层和输出层的是W2和b2,输入就是隐藏层输入的H值。同样是通过矩阵运算进行的：
$Y=w2<em>H+b2$
最终输出层，最终是4个象限
H是4</em>50的矩阵，输出层的w2矩阵就是个50<em>4,最终得到一个4</em>4的矩阵
这里不详细画图了，大概意义如下。</p>
<ol>
<li>H是4*50的矩阵其实是一个列是神经元50个，行是4个数据集的经过第一轮计算的输出值H，隐藏层的目的就是计算出一个H值。</li>
<li>输出层的 w矩阵是50*4，目的是为了将50个神经元压缩到4个输出特征，也就是每一个数据集在4个象限的概率。所以最终输出是4*4</li>
</ol>
<h3 id="激活层">激活层</h3>
<p>通过上述两个线性方程的计算，我们就能得到最终的输出Y了，但是如果你还对线性代数的计算有印象的话，应该会知道：一系列线性方程的运算最终都可以用一个线性方程表示。也就是说，上述两个式子联立后可以用一个线性方程表达。对于两次神经网络是这样，就算网络深度加到100层，也依然是这样。这样的话神经网络就失去了意义。
所以这里要对网络注入灵魂：激活层。
简而言之，激活层是为矩阵运算的结果添加非线性的
具体为什么需要，请view：https://blog.csdn.net/liaomin416100569/article/details/130597944?spm=1001.2014.3001.5501</p>
<p>激活层是神经网络中的一种层，其作用是在输入信号和输出信号之间添加一个非线性的转换函数，使得网络可以更好地学习和表示复杂的非线性关系。激活层的意义在于增加模型的非线性表达能力，使得神经网络可以更好地处理复杂的输入数据，例如图像、文本和语音等。激活函数的选择也非常重要，不同的激活函数具有不同的特点。
激活层常用的激活函数三种，分别是阶跃函数、Sigmoid和ReLU，如下图：
<a href="#R-image-7ba83e79f4f2fa1500f3afcd50448fa5" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/12e440c3a65c976cad0599a5e05a858f.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7ba83e79f4f2fa1500f3afcd50448fa5"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/12e440c3a65c976cad0599a5e05a858f.png"></a></p>
<ul>
<li>阶跃函数：当输入小于等于0时，输出0；当输入大于0时，输出1。</li>
<li>Sigmoid：当输入趋近于正无穷/负无穷时，输出无限接近于1/0。</li>
<li>ReLU：当输入小于0时，输出0；当输入大于0时，输出等于输入。</li>
</ul>
<p>其中，阶跃函数输出值是跳变的，且只有二值，较少使用；Sigmoid函数在当x的绝对值较大时，曲线的斜率变化很小（梯度消失），并且计算较复杂；ReLU是当前较为常用的激活函数。</p>
<p>激活函数具体是怎么计算的呢？
假如经过公式H=X*W1+b1计算得到的H值为：(1,-2,3,-4,7&hellip;)，那么经过阶跃函数激活层后就会变为(1,0,1,0,1&hellip;)，经过ReLU激活层之后会变为(1,0,3,0,7&hellip;)。</p>
<p>需要注意的是，每个隐藏层计算（矩阵线性运算）之后，都需要加一层激活层，要不然该层线性计算是没有意义的。
此时的神经网络变成了如下图所示的形式：
<a href="#R-image-442b897ed1aa2df5ccc9a970b942ba9e" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/aac9ed823391f1de263821731d37f805.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-442b897ed1aa2df5ccc9a970b942ba9e"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/aac9ed823391f1de263821731d37f805.png"></a>
我们都知道（？）神经网络是分为“训练”和“使用”两个步骤的。如果是在“使用”的步骤，图4就已经完成整个过程了，在求得的Y（大小为4*4）矩阵中，当前样本数值最大的就代表着当前分类。</p>
<p>但是对于用于“训练”的网络，上图还远远不够。起码当前的输出Y，还不够“漂亮”。</p>
<h3 id="输出的正规化">输出的正规化</h3>
<p>假设某个样本输出Y的值可能会是(3,1,0.1,0.5)这样的矩阵，诚然我们可以找到里边的最大值“3”，从而找到对应的分类为I，但是这并不直观。我们想让最终的输出为概率，也就是说可以生成像(90%,5%,2%,3%)这样的结果，这样做不仅可以找到最大概率的分类，而且可以知道各个分类计算的概率值。
具体是怎么计算的呢？
计算公式如下：
<a href="#R-image-15825f74bac95a80dacf269e290cee37" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/c7040b35c664e79d595ed94f895abd2f.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-15825f74bac95a80dacf269e290cee37"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/c7040b35c664e79d595ed94f895abd2f.png"></a>
简单来说分三步进行：（1）以e为底对所有元素求指数幂；（2）将所有指数幂求和；（3）分别将这些指数幂与该和做商。</p>
<p>这样求出的结果中，所有元素的和一定为1，而每个元素可以代表概率值。</p>
<p>我们将使用这个计算公式做输出结果正规化处理的层叫做“Softmax”层。此时的神经网络将变成如下图所示：
<a href="#R-image-9aedc73dd7e2e4341e7694b4670b40b8" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/2751fb29578621358528e9fe8c9f7d8d.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9aedc73dd7e2e4341e7694b4670b40b8"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/2751fb29578621358528e9fe8c9f7d8d.png"></a></p>
<h3 id="如何衡量输出的好坏">如何衡量输出的好坏</h3>
<p>通过Softmax层之后，我们得到了I，II，III和IV这四个类别分别对应的概率，但是要注意，这是神经网络计算得到的概率值结果，而非真实的情况。</p>
<p>比如，Softmax输出的结果是(90%,5%,3%,2%)，真实的结果是(100%,0,0,0)。虽然输出的结果可以正确分类，但是与真实结果之间是有差距的，一个优秀的网络对结果的预测要无限接近于100%，为此，我们需要将Softmax输出结果的好坏程度做一个“量化”。</p>
<p>一种直观的解决方法，是用1减去Softmax输出的概率，比如1-90%=0.1。不过更为常用且巧妙的方法是，求对数的负数。</p>
<p>还是用90%举例，对数的负数就是：-log0.9=0.046</p>
<p>可以想见，概率越接近100%，该计算结果值越接近于0，说明结果越准确，该输出叫做“交叉熵损失（Cross Entropy Error）”。</p>
<p>我们训练神经网络的目的，就是尽可能地减少这个“交叉熵损失”。
<a href="#R-image-efd768871ff42b3d7bc6be098443854a" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/d6922c4a22cfab022a036e87309efab3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-efd768871ff42b3d7bc6be098443854a"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/d6922c4a22cfab022a036e87309efab3.png"></a></p>
<h3></h3>
<h3 id="反向传播与参数优化">反向传播与参数优化</h3>
<p>上面的过程其实就是神经网络的正向传播过程 ，一句话复习一下：神经网络的传播都是形如Y=WX+b的矩阵运算；为了给矩阵运算加入非线性，需要在隐藏层中加入激活层；输出层结果需要经过Softmax层处理为概率值，并通过交叉熵损失来量化当前网络的优劣。</p>
<p>算出交叉熵损失后，就要开始反向传播了。其实反向传播就是一个参数优化的过程，优化对象就是网络中的所有W和b（因为其他所有参数都是确定的）。</p>
<p>神经网络的神奇之处，就在于它可以自动做W和b的优化，在深度学习中，参数的数量有时会上亿，不过其优化的原理和我们这个两层神经网络是一样的。</p>
<p>神经网络需要反复迭代。如上述例子中，第一次计算得到的概率是90%，交叉熵损失值是0.046；将该损失值反向传播，使W1,b1,W2,b2做相应微调；再做第二次运算，此时的概率可能就会提高到92%，相应地，损失值也会下降，然后再反向传播损失值，微调参数W1,b1,W2,b2。依次类推，损失值越来越小，直到我们满意为止。</p>
<p>此时我们就得到了理想的W1,b1,W2,b2。</p>
<p>具体参考 BP算法怎推导章节</p>
<blockquote>
<p>内容参考：https://zhuanlan.zhihu.com/p/65472471</p></blockquote>
<h3 id="过拟合">过拟合</h3>
<p>Dropout是一种在神经网络中用于防止过拟合的技术。它是通过在训练期间随机将一些节点的输出设置为0来实现的。具体来说，每个节点有一定的概率被“关闭”，即其输出被设置为0。这样，节点之间的连接就会被随机断开，从而迫使网络学习更加鲁棒的特征，而不是依赖特定的节点或连接。这种随机性可以被看作是一种正则化技术，可以有效地防止过拟合。</p>
<p>过拟合是指模型在训练数据上表现很好，但在测试数据上表现不佳的现象。这通常是由于模型过于复杂，而训练数据又过少或过于噪声导致的。通过使用Dropout技术，我们可以减少模型的复杂度，并使其更加适应不同的训练数据。这样，我们就可以更好地泛化模型，从而在测试数据上获得更好的表现。</p>
<p>假设我们有一个二分类任务，需要从图像中识别猫和狗。我们使用卷积神经网络进行训练，但由于数据集较小，容易出现过拟合的问题。</p>
<p>为了解决这个问题，我们可以在卷积神经网络中添加Dropout层。例如，我们可以在全连接层之前添加一个Dropout层，将其输出概率设置为0.5。这意味着在每个训练批次中，该层中的一半节点的输出将被随机设置为0。这样，网络就不会过于依赖特定节点或连接，并且可以更好地适应不同的训练数据。</p>
<h2 id="bp算法推导">BP算法推导</h2>
<h3 id="定义">定义</h3>
<p>首先来一个反向传播算法的定义（转自维基百科）：反向传播（英语：Backpropagation，缩写为BP）是“误差反向传播”的简称，是一种与最优化方法（如梯度下降法）结合使用的，用来训练人工神经网络的常见方法。 该方法对网络中所有权重计算损失函数的梯度。 这个梯度会反馈给最优化方法，用来更新权值以最小化损失函数。（误差的反向传播）</p>
<h3 id="算法讲解">算法讲解</h3>
<p>如果去问一下了解BP算法的人“BP算法怎推导？”，大概率得到的回答是“不就是链式求导法则嘛”，我觉得这种答案对于提问题的人来说没有任何帮助。BP的推导需要链式求导不错，但提问者往往想得到的是直观的回答，毕竟理解才是王道。直观的答案，非图解莫属了。
注：下图的确是反向传播算法，但不是深度学习中的backprop，不过backward的大体思想是一样的，毕竟误差没法从前往后计算啊。（在深度学习中操作的是计算图—Computational graph），如果暂时不理解上面那句话，你可以当我没说过，不要紧~（手动?）</p>
<p>下面通过两组图来进行神经网络前向传播和反向传播算法的讲解，第一组图来自国外某网站，配图生动形象。如果对你来说，单纯的讲解理解起来比较费劲，那么可以参考第二组图——一个具体的前向传播和反向传播算法的例子。相信就算是刚刚入门的小白（只要有一点点高等数学基础知识），也一定可以理解反向传播算法！</p>
<p>首先拿一个简单的三层神经网络来举例，如下：
<a href="#R-image-3fd33e5af1b709d1a5166fe59255e71a" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/8ca07945a8ddd2f6334e32a5dee95b88.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3fd33e5af1b709d1a5166fe59255e71a"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/8ca07945a8ddd2f6334e32a5dee95b88.png"></a>
每个神经元由两部分组成，第一部分（e）是输入值和权重系数乘积的和，第二部分（f(e)）是一个激活函数（非线性函数）的输出， y=f(e)即为某个神经元的输出，如下：
<a href="#R-image-0051ceab418b1b267c4f1b0cdb2704db" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/a0c439f52fe8b45ccd85d60b9e49f3ec.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0051ceab418b1b267c4f1b0cdb2704db"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/a0c439f52fe8b45ccd85d60b9e49f3ec.png"></a></p>
<h4 id="前向传播">前向传播</h4>
<p>第一层神经网络传播</p>
<blockquote>
<p>其中$w_{x1}1$表示x1对应第一个神经元的w值，$w_{x2}1$，表示x2对应对一个神经元的w值。</p></blockquote>
<p><a href="#R-image-2f76ca69a15a2d0039666e267a10c2c0" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/7bf0782ee01f1fd29ad80a5319a8141a.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2f76ca69a15a2d0039666e267a10c2c0"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/7bf0782ee01f1fd29ad80a5319a8141a.png"></a>
第二层神经网络传播
<a href="#R-image-a92f33acb225da692a8d7d398548b3c4" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/fd0be01b49aa9a33c21a3367e3d21c6a.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a92f33acb225da692a8d7d398548b3c4"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/fd0be01b49aa9a33c21a3367e3d21c6a.png"></a>
第三层神经网络传播
<a href="#R-image-fcf8315d2b674f5268ea4c845d3b3126" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/35902aac57a0b16b4b2bb9346c3a76c8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fcf8315d2b674f5268ea4c845d3b3126"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/35902aac57a0b16b4b2bb9346c3a76c8.png"></a></p>
<h4 id="反向传播">反向传播</h4>
<p>到这里为止，神经网络的前向传播已经完成，最后输出的y就是本次前向传播神经网络计算出来的结果（预测结果），但这个预测结果不一定是正确的，要和真实的标签（z）相比较，计算预测结果和真实标签的误差（$\delta$），如下：
<a href="#R-image-5c63e5fca60e4c0d1b9beb7838692f3d" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/d513a818f7bf8a835c35b7ccd28770e7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5c63e5fca60e4c0d1b9beb7838692f3d"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/d513a818f7bf8a835c35b7ccd28770e7.png"></a>
下面开始计算每个神经元的误差（$\delta$）
<a href="#R-image-17e6f00e2a122900973b644f74aa114b" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/68d9b04e6558e3bb5c3c6d57851ee769.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-17e6f00e2a122900973b644f74aa114b"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/68d9b04e6558e3bb5c3c6d57851ee769.png"></a>
计算第一层误差
<a href="#R-image-0729343d5f10cdd5ce11cf695bcd9a68" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/74f07e9562928028f09e00916990c1ed.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0729343d5f10cdd5ce11cf695bcd9a68"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/74f07e9562928028f09e00916990c1ed.png"></a>
下面开始利用反向传播的误差，计算各个神经元（权重）的导数，开始反向传播修改权重
<a href="#R-image-526060eb3475dfe889b34710e5722eee" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/d42f378d56bf36ddacf62a79bd2b8e43.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-526060eb3475dfe889b34710e5722eee"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/d42f378d56bf36ddacf62a79bd2b8e43.png"></a>
<a href="#R-image-d78d69b0a180816238a42d8960d812a4" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/f031883c0df8d407cf50d030de0f6ce2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d78d69b0a180816238a42d8960d812a4"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/f031883c0df8d407cf50d030de0f6ce2.png"></a>
计算第二次的w
<a href="#R-image-2f830d907ceae48f9efb99f91d2cf8fa" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/f60344e7e9bc805c5ce277fc3312d4e2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2f830d907ceae48f9efb99f91d2cf8fa"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/f60344e7e9bc805c5ce277fc3312d4e2.png"></a>
计算第三层
<a href="#R-image-a45ee46e0a3eeb68206589396cf02571" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/c210c6b4fc279dddad9e005a6fc4f236.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a45ee46e0a3eeb68206589396cf02571"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/c210c6b4fc279dddad9e005a6fc4f236.png"></a>
到此为止，整个网络的前向，反向传播和权重更新已经完成</p>
<h3 id="具体实例">具体实例</h3>
<p>就算上面的所有东西你都看的迷迷糊糊，通过下面的例子，相信绝大多数人也能很轻松的理解BP算法。如图是一个简单的神经网络用来举例：
<a href="#R-image-b0e48f920c7cb0db105ea591201b009a" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/61e1de4d735cea9de4bafbe1d61f1ae7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b0e48f920c7cb0db105ea591201b009a"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/61e1de4d735cea9de4bafbe1d61f1ae7.png"></a>
下面是前向（前馈）运算（激活函数为sigmoid）：
<a href="#R-image-4c78ea78826b43e8b64d2ceb85ca7338" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/6735b99079934d81215e58dbf10fd49b.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4c78ea78826b43e8b64d2ceb85ca7338"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/6735b99079934d81215e58dbf10fd49b.png"></a>
下面是反向传播（求网络误差对各个权重参数的梯度）：</p>
<p>我们先来求最简单的，求误差E对w5的导数。首先明确这是一个“链式求导”过程，要求误差E对w5的导数，需要先求误差E对out o1的导数，再求out o1对net o1的导数，最后再求net o1对w5的导数，经过这个链式法则，我们就可以求出误差E对w5的导数（偏导），如下图所示：
<a href="#R-image-b1f805e558c3c9f4deae0e18718d2b97" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/161b75d6ad4640998cffa4d6bdf0d653.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b1f805e558c3c9f4deae0e18718d2b97"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/161b75d6ad4640998cffa4d6bdf0d653.png"></a>
导数（梯度）已经计算出来了，下面就是反向传播与参数更新过程：
<a href="#R-image-cfc5071ad697e7f6b19414773fbc666e" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/a2998cdb814362f5c2a06157b6afe1ab.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cfc5071ad697e7f6b19414773fbc666e"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/a2998cdb814362f5c2a06157b6afe1ab.png"></a>
上面的图已经很显然了，如果还看不懂真的得去闭门思过了（开玩笑~），耐心看一下上面的几张图，一定能看懂的。</p>
<p>如果要想求误差E对w1的导数，误差E对w1的求导路径不止一条，这会稍微复杂一点，但换汤不换药，计算过程如下所示：
<a href="#R-image-9d1adc358d7fae4d96f528bad6b75f40" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/5fa6eda140530f8b310a61c052461ae7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9d1adc358d7fae4d96f528bad6b75f40"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/5fa6eda140530f8b310a61c052461ae7.png"></a></p>
<blockquote>
<p>bp推导参考：https://blog.csdn.net/ft_sunshine/article/details/90221691</p></blockquote>
<h2 id="tensorflow实战">tensorflow实战</h2>
<h3 id="加载数据集">加载数据集</h3>
<p>keras.datasets.mnist 是 Keras 框架内置的一个手写数字数据集，包含了 60,000 张训练图片和 10,000 张测试图片。每张图片都是 28x28 像素的灰度图像，每个像素的取值范围为 0 到 255。该数据集常用于机器学习领域中的图像分类和数字识别任务。</p>
<p>keras.datasets.mnist 的返回值是一个元组 (x_train, y_train), (x_test, y_test)，分别表示训练集和测试集。其中 x_train 和 x_test 分别是形状为 (60000, 28, 28) 和 (10000, 28, 28) 的 numpy 数组，表示图像数据。y_train 和 y_test 则是形状为 (60000,) 和 (10000,) 的 numpy 数组，表示对应的图像标签，即每张图片所代表的数字。
记载数据集，并绘制前20张图片</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>#%%

from tensorflow.keras.datasets import mnist
import matplotlib.pyplot as plt

# 加载数据集
(x_train, y_train), (x_test, y_test) = mnist.load_data()
x_test_ori=x_test 
# 打印数据集信息
print(&#39;训练集图像数据形状：&#39;, x_train.shape)
print(&#39;训练集标签数据形状：&#39;, y_train.shape)
print(&#39;测试集图像数据形状：&#39;, x_test.shape)
print(&#39;测试集标签数据形状：&#39;, y_test.shape)

# 绘制前20张训练集图像
plt.figure(figsize=(10, 10))
for i in range(20):
    plt.subplot(5, 5, i+1)
    plt.xticks([])
    plt.yticks([])
    plt.grid(False)
    plt.imshow(x_train[i], cmap=plt.cm.binary)
    plt.xlabel(y_train[i])
plt.show()</code></pre></div>
<p>输出</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>训练集图像数据形状： (60000, 28, 28)
训练集标签数据形状： (60000,)
测试集图像数据形状： (10000, 28, 28)
测试集标签数据形状： (10000,)</code></pre></div>
<p><a href="#R-image-d2d2560e1b1261c8c9c224ea6ba28bab" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/382c3231801af5e5b73b238551be3201.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d2d2560e1b1261c8c9c224ea6ba28bab"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/382c3231801af5e5b73b238551be3201.png"></a></p>
<blockquote>
<p>默认图片下载路径在  ~/.keras/datasets  ，window下：C:\Users\当前用户名.keras\datasets,大小估计10MB左右。</p></blockquote>
<h3 id="数据预处理">数据预处理</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>x_train = x_train.reshape(x_train.shape[0], 784).astype(&#39;float32&#39;) / 255
x_test = x_test.reshape(x_test.shape[0], 784).astype(&#39;float32&#39;) / 255
y_train = keras.utils.to_categorical(y_train, 10)
y_test = keras.utils.to_categorical(y_test, 10)</code></pre></div>
<p>在上面的代码中，我们将输入数据的维度从 28x28 转换为 784，因为我们处理的数据一般都是一个矩阵，一行代表一个数据样本，需要转换成784*1的数据，并将像素值的范围从 0-255 缩放到 0-1 之间。同时，我们将标签数据进行 one-hot 编码，将其转换为一个 10 维的向量，每个维度代表一个数字。</p>
<h4 id="one-host编码">one-host编码</h4>
<p>One-hot编码是一种将离散型变量转换为连续型变量的技术，在机器学习和深度学习中广泛应用。它将每个离散型变量的取值都编码为一个二进制位，其中只有一个二进制位为1，其余二进制位为0。举例说明如下：</p>
<p>假设有一个离散型变量“颜色”，它的可能取值为“红色”、“黄色”和“蓝色”。我们可以将这三个取值编码为长度为3的二进制向量，如下所示：</p>
<p>红色：[1, 0, 0]</p>
<p>黄色：[0, 1, 0]</p>
<p>蓝色：[0, 0, 1]</p>
<p>这个编码方式就是one-hot编码。在机器学习中，我们可以使用这个编码方式来处理离散型变量，使其成为连续型变量，方便模型的学习和使用。</p>
<h4 id="kerasutilsto_categorical">keras.utils.to_categorical()</h4>
<p><code>keras.utils.to_categorical()</code>函数将整数型的类别标签转换成了独热编码（one-hot encoding）的形式。在独热编码中，每个类别标签被表示为一个长度等于类别总数的向量，其中该类别标签所对应的位置值为1，其余位置为0。</p>
<p>对于手写数字识别任务，共有10个类别，即数字0到9，因此需要将标签向量转换为10维的独热编码。</p>
<p>例如，如果原始标签为5，则转换后的独热编码为<code>[0, 0, 0, 0, 0, 1, 0, 0, 0, 0]</code>，其中第6个位置（从0开始）的值为1，表示原始标签为5。</p>
<p>这样做的目的是为了让神经网络更好地理解类别之间的差异和相似性，以便更准确地进行分类预测。</p>
<h3 id="构造多层感知器模型">构造多层感知器模型</h3>
<p>我们使用 keras.Sequential 构建模型，该模型包含一个输入层、一个隐藏层和一个输出层。输入层的维度为 784（即每个图片的像素数），隐藏层包含 512 个神经元，激活函数为 ReLU，输出层包含 10 个神经元，激活函数为 softmax。同时，我们使用 Dropout 防止过拟合。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code># 构建模型
model = tf.keras.Sequential([
    tf.keras.layers.Dense(512, activation=&#39;relu&#39;, input_shape=(784,)),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Dense(10, activation=&#39;softmax&#39;)
])</code></pre></div>
<h4 id="tfkerassequential">tf.keras.Sequential</h4>
<p>keras.Sequential是Keras中的一个类，用于快速搭建神经网络模型。它提供了一个简单的方法来创建顺序模型，即一系列层按照顺序堆叠在一起的模型。在keras.Sequential中，可以通过添加层的方式来搭建神经网络。</p>
<p>keras.Sequential的定义如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>keras.Sequential(
    layers=None, 
    name=None
)</code></pre></div>
<p>其中，layers是一个列表，包含了按照顺序堆叠在一起的层；name是模型的名称。
上面使用keras.Sequential创建简单神经网络的例子：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>model = tf.keras.Sequential([
    tf.keras.layers.Dense(512, activation=&#39;relu&#39;, input_shape=(784,)),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Dense(10, activation=&#39;softmax&#39;)
])</code></pre></div>
<p>我们创建了一个包含三层的神经网络模型。第一层是一个全连接层，包含512个神经元，使用ReLU激活函数，输入形状为(784,)。第二层是一个Dropout层，第三层是一个全连接层包含10个神经元，使用Softmax激活函数。</p>
<h4 id="keraslayersdense">keras.layers.Dense</h4>
<p>keras.layers.Dense是Keras中的一个类，用于创建全连接层。全连接层是神经网络中最基本的一种层，它的每一个神经元都与上一层的每一个神经元相连。keras.layers.Dense可以用于创建输入层、输出层和隐藏层。</p>
<p>keras.layers.Dense的定义如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>keras.layers.Dense(
    units, 
    activation=None, 
    use_bias=True, 
    kernel_initializer=&#39;glorot_uniform&#39;, 
    bias_initializer=&#39;zeros&#39;, 
    kernel_regularizer=None, 
    bias_regularizer=None, 
    activity_regularizer=None, 
    kernel_constraint=None, 
    bias_constraint=None, 
    **kwargs
)</code></pre></div>
<p>其中，units表示该层的神经元数量；activation表示该层的激活函数；use_bias表示是否使用偏置；kernel_initializer表示权重矩阵的初始化方法；bias_initializer表示偏置向量的初始化方法；kernel_regularizer、bias_regularizer、activity_regularizer表示正则化项；kernel_constraint、bias_constraint表示约束项。</p>
<p>下面是一个使用keras.layers.Dense创建全连接层的例子：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>import tensorflow.keras as keras
layer =  tf.keras.layers.Dense(512, activation=&#39;relu&#39;, input_shape=(784,)),</code></pre></div>
<p>在这个例子中，我们创建了一个包含512个神经元的全连接层。激活函数为ReLU，输入形状为(784,)，表示该层的输入数据是一个长度为784的向量。</p>
<p>keras.layers.Dense的一些常用参数和方法：</p>
<ul>
<li>units：该层的神经元数量；</li>
<li>activation：该层的激活函数；</li>
<li>use_bias：是否使用偏置；</li>
<li>kernel_initializer：权重矩阵的初始化方法；</li>
<li>bias_initializer：偏置向量的初始化方法；</li>
<li>kernel_regularizer、bias_regularizer、activity_regularizer：正则化项；</li>
<li>kernel_constraint、bias_constraint：约束项；</li>
<li>layer.get_weights()：获取该层的权重矩阵和偏置向量；</li>
<li>layer.set_weights(weights)：设置该层的权重矩阵和偏置向量。
以上就是keras.layers.Dense的一些基本信息和使用方法。</li>
</ul>
<h4 id="keraslayersdropout">keras.layers.Dropout</h4>
<p>tf.keras.layers.Dropout是一种在神经网络中应用的正则化方法，用于减少过拟合的影响。在训练期间，Dropout层会随机地将输入张量的一部分元素设置为0，从而强制网络学习更健壮的特征表示，防止过拟合。具体来说，Dropout层以一定的概率（通常为0.5）随机地将输入张量的一部分神经元输出设为0，这些被屏蔽的神经元将不会参与前向传播和反向传播。这样做可以强制网络在训练过程中学习到更多的特征，并且使得网络对于输入的微小变化更加稳健。</p>
<p>在tf.keras.layers.Dropout中，可以设置一个rate参数，来控制屏蔽神经元的比例，即随机将输入张量的多少个元素置为0。具体来说，如果rate=0.5，则代表在训练过程中随机选取50%的神经元输出为0，而在测试过程中不会进行任何操作。同时，可以将tf.keras.layers.Dropout层放在神经网络的任何位置，通常放在全连接层之后，以减少过拟合的影响。</p>
<p>Dropout层的主要作用是减少过拟合的影响，从而提高模型的泛化能力。通过随机屏蔽部分神经元，Dropout层可以强制网络学习到更健壮的特征表示，并且使得网络对于输入的微小变化更加稳健。这样可以增加模型的鲁棒性，提高模型的泛化能力，从而使得模型在测试集上表现更好。</p>
<p>需要注意的是，在测试过程中不应该使用Dropout层，因为测试过程需要对整个模型进行前向传播，而不是将部分神经元置为0。因此，在测试过程中，需要将所有的神经元都参与前向传播，以获得更准确的预测结果。为了解决这个问题，可以在训练过程中使用Dropout层，并在测试过程中关闭Dropout层，或者根据Dropout的特性对输出进行调整。</p>
<h4 id="keraslayers其他">keras.layers.其他</h4>
<p><code>keras.layers</code> 模块提供了许多常见的神经网络层类，其中一些常用的层包括：</p>
<ul>
<li><code>Dense</code>：全连接层，每个输入节点都连接到输出节点</li>
<li><code>Conv2D</code>：二维卷积层，对图像或其他二维输入进行卷积运算</li>
<li><code>MaxPooling2D</code>：二维最大池化层，对输入进行下采样</li>
<li><code>Dropout</code>：随机丢弃一部分输入节点，以减少过拟合</li>
<li><code>Flatten</code>：将输入展平为一维张量</li>
<li><code>Activation</code>：激活函数层，如ReLU、Sigmoid、Softmax等</li>
<li><code>BatchNormalization</code>：批量归一化层，用于加速收敛和减少过拟合</li>
<li><code>Embedding</code>：词嵌入层，将离散的词转换为连续的向量表示</li>
<li><code>LSTM</code>：长短时记忆循环层，用于处理时间序列数据</li>
<li><code>GRU</code>：门控循环单元层，用于处理时间序列数据</li>
</ul>
<p>这些层可以通过组合或堆叠来构建复杂的神经网络模型。除了这些常用的层外，<code>keras.layers</code> 还提供了许多其他层，如 <code>Conv1D</code>、<code>Conv3D</code>、<code>UpSampling2D</code>、<code>SeparableConv2D</code>、<code>GlobalMaxPooling2D</code>、<code>GlobalAveragePooling2D</code>等等。可以根据具体的任务需求选择合适的层。</p>
<h3 id="模型编译">模型编译</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>model.compile(optimizer=&#39;adam&#39;,
              loss=&#39;categorical_crossentropy&#39;,
              metrics=[&#39;accuracy&#39;])</code></pre></div>
<p>这段代码是用来编译模型的，其中包含了三个参数：</p>
<ol>
<li>
<p>optimizer：优化器，用来控制模型的学习速率。在这里，我们使用了Adam优化器，这是目前被广泛使用的一种优化器，它可以自适应地调整学习速率。</p>
</li>
<li>
<p>loss：损失函数，用来衡量模型在训练过程中的误差。在这里，我们使用了交叉熵损失函数，它适用于多分类问题，能够有效地衡量模型预测结果与真实标签之间的差异。</p>
</li>
<li>
<p>metrics：评价指标，用来评价模型的性能。在这里，我们使用了准确率作为评价指标，它可以衡量模型在测试集上的分类精度。</p>
</li>
</ol>
<p>总的来说，这段代码的作用是为模型指定优化器、损失函数和评价指标，以便在训练过程中使用。</p>
<h4 id="优化器">优化器</h4>
<p>常用的优化器有以下几种：</p>
<ol>
<li>
<p>随机梯度下降（Stochastic Gradient Descent，SGD）：是最基础、最简单的优化器，通过不断迭代来寻找最优解，对应字符串为：&lsquo;sgd&rsquo;。</p>
</li>
<li>
<p>Adam：是目前最广泛使用的优化器之一，结合了Adagrad和RMSprop的优点，对应字符串为：&lsquo;adam。</p>
</li>
<li>
<p>Adagrad：自适应地调整每个参数的学习率，适用于稀疏数据集，对应字符串为：&lsquo;adagrad。</p>
</li>
<li>
<p>RMSprop：与Adagrad类似，但是对梯度的平方进行指数加权移动平均，能够更好地适应非平稳目标函数，对应字符串为：&lsquo;rmsprop。</p>
</li>
<li>
<p>Adadelta：结合了Adagrad和RMSprop的优点，同时解决了Adagrad学习率下降快的问题，对应字符串为：&lsquo;adadelta。</p>
</li>
<li>
<p>Adamax：是Adam的一种变体，使用了L∞范数来代替L2范数，对应字符串为：&lsquo;adamax。</p>
</li>
<li>
<p>Nadam：是Adam和Nesterov动量的结合体，能够更好地适应凸函数和非凸函数，对应字符串为：&rsquo;nadam。</p>
</li>
</ol>
<p>以上是常用的优化器，每种优化器都有其优点和缺点，选择合适的优化器需要根据具体的场景和任务来进行选择。</p>
<h4 id="损失函数">损失函数</h4>
<p>常见的损失函数包括：</p>
<ol>
<li>
<p>均方误差（Mean Squared Error，MSE）：该损失函数常用于回归问题，计算预测值与真实值之间的差平方的平均值。
在Keras中的字符串表示为：&lsquo;mse&rsquo;</p>
</li>
<li>
<p>交叉熵损失函数（Cross Entropy Loss，CE）：该损失函数常用于分类问题，通过计算预测值和真实值之间的交叉熵来衡量模型的拟合能力。
在Keras中的字符串表示为：&lsquo;categorical_crossentropy&rsquo;（用于多分类问题）或&rsquo;binary_crossentropy&rsquo;（用于二分类问题）。</p>
</li>
<li>
<p>对数损失函数（Logarithmic Loss，LogLoss）：该损失函数常用于二分类问题，通过计算预测值和真实值之间的对数损失来衡量模型的拟合能力。
在Keras中的字符串表示为：&lsquo;binary_crossentropy&rsquo;</p>
</li>
<li>
<p>Hinge损失函数：该损失函数常用于支持向量机（SVM）模型中，通过计算预测值和真实值之间的Hinge损失来衡量模型的拟合能力。
在Keras中的字符串表示为：&lsquo;hinge&rsquo;</p>
</li>
<li>
<p>Huber损失函数：该损失函数常用于回归问题，通过计算预测值和真实值之间的平滑L1损失来衡量模型的拟合能力。
在Keras中的字符串表示为：&lsquo;huber_loss&rsquo;</p>
</li>
</ol>
<p>当然，这些只是常见的损失函数，还有其他的损失函数，比如Focal Loss等。</p>
<h4 id="评价指标">评价指标</h4>
<p>常见的评价指标包括：</p>
<ol>
<li>
<p>准确率（Accuracy）：该指标用于分类问题，表示模型正确分类的样本数占总样本数的比例。
在Keras中的字符串表示为：&lsquo;accuracy&rsquo;</p>
</li>
<li>
<p>精确率（Precision）：该指标用于分类问题，表示模型正确预测为正类的样本数占预测为正类的样本总数的比例。
在Keras中的字符串表示为：&lsquo;precision&rsquo;</p>
</li>
<li>
<p>召回率（Recall）：该指标用于分类问题，表示模型正确预测为正类的样本数占真实为正类的样本总数的比例。
在Keras中的字符串表示为：&lsquo;recall&rsquo;</p>
</li>
<li>
<p>F1分数（F1 Score）：该指标综合了精确率和召回率，是二者的调和平均数，可以更全面地评估模型的性能。
在Keras中的字符串表示为：&lsquo;f1_score&rsquo;</p>
</li>
<li>
<p>均方误差（Mean Squared Error，MSE）：该指标用于回归问题，表示模型预测值与真实值之间的平均平方误差。
在Keras中的字符串表示为：&lsquo;mse&rsquo;</p>
</li>
<li>
<p>平均绝对误差（Mean Absolute Error，MAE）：该指标用于回归问题，表示模型预测值与真实值之间的平均绝对误差。
在Keras中的字符串表示为：&lsquo;mae&rsquo;</p>
</li>
</ol>
<p>当然，这些只是常见的评价指标，还有其他的评价指标，比如AUC等。</p>
<h3 id="模型训练">模型训练</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>history = model.fit(x_train, y_train, 
                    epochs=10, 
                    batch_size=128, 
                    validation_data=(x_test, y_test))</code></pre></div>
<p>在上面的代码中，我们使用 model.fit 进行模型训练，设置了 10 个 epochs 和 128 个批次大小。同时，我们使用测试集进行模型验证。</p>
<p>在每个epoch中，模型需要对整个训练数据集进行训练，而不是仅仅针对一个样本或一个batch进行训练。因此，在每个epoch中，模型需要对所有训练样本进行前向传播和反向传播，以计算出每个样本对应的误差和梯度，并使用这些梯度更新模型的权重参数。</p>
<p>为了加快模型训练的速度，通常会将训练数据集分成多个batch，每个batch包含若干个样本。在每个epoch中，模型会将整个训练数据集分成多个batch，然后对每个batch进行前向传播和反向传播，以更新权重参数。因此，在每个epoch中，模型需要进行多次前向传播和反向传播，才能完成对整个训练数据集的训练。</p>
<p>如果batch_size=128，在一次epochs中数据被拆成了128份，每一份都和512个神经元进行正向和反向传播进行梯度下降修正w和b，所以一次epochs，实际上进行了128次的梯度下降算法
如果设置成10个epoch，可以理解为128*10次梯度下降算法。
像手写数字识别的，数据进行两次epoch,进行256次梯度下降，准确率就达到97%了</p>
<blockquote>
<p>注意别6w个样本一批次处理，内存罩不住啊，可能执行1个epochs都要几个小时。</p></blockquote>
<h3 id="模型评估">模型评估</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code># 评估模型
test_loss, test_acc = model.evaluate(x_test, y_test)
print(&#39;Test accuracy:&#39;, test_acc)

# 预测结果
predictions = model.predict(x_test)</code></pre></div>
<p>在上面的代码中，我们使用 model.evaluate 对模型进行评估，并使用 model.predict 进行预测。</p>
<p>如果运行过程中报错</p>
<blockquote>
<p>InternalError:  Attempting to perform BLAS operation using StreamExecutor without BLAS support
[[node sequential/dense/MatMul (defined at C:\Users\liaomin\AppData\Local\Temp\ipykernel_28392\2909523142.py:25) ]] [Op:__inference_test_function_361]</p></blockquote>
<p>直接安装即可,gpu版本tensorflow需要blas库，cpu版本不需要</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>conda install blas</code></pre></div>
<h3 id="模型预测">模型预测</h3>
<p>选择某个测试元素然后将图片显示出来，并使用模型预测</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code># 预测第10个测试数据的结果
predictions = model.predict(np.array([x_test[9]]))
print(&#34;预测结果：&#34;, np.argmax(predictions))

# 绘制第10个测试数据的图形
plt.imshow(x_test_ori[9], cmap=plt.cm.binary)
plt.show()</code></pre></div>
<p><a href="#R-image-5b4c5e5860eeb5fda3b3a2c192398b89" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/e241ed696113c899c4d0ab45a8f7d182.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5b4c5e5860eeb5fda3b3a2c192398b89"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/e241ed696113c899c4d0ab45a8f7d182.png"></a></p>
<h3 id="完整运行">完整运行</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>#%%

#%%

import tensorflow as tf
from tensorflow.keras.datasets import mnist
import numpy as np
import matplotlib.pyplot as plt
# 加载数据集
(x_train, y_train), (x_test, y_test) = mnist.load_data()
x_test_ori=x_test
# 数据预处理
x_train = x_train.reshape(x_train.shape[0], 784).astype(&#39;float32&#39;) / 255
x_test = x_test.reshape(x_test.shape[0], 784).astype(&#39;float32&#39;) / 255
y_train = tf.keras.utils.to_categorical(y_train, 10)
y_test = tf.keras.utils.to_categorical(y_test, 10)

# 构建模型
model = tf.keras.Sequential([
    tf.keras.layers.Dense(512, activation=&#39;relu&#39;, input_shape=(784,)),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Dense(10, activation=&#39;softmax&#39;)
])

# 编译模型
model.compile(optimizer=&#39;adam&#39;,
              loss=&#39;categorical_crossentropy&#39;,
              metrics=[&#39;accuracy&#39;])
# 训练模型
history = model.fit(x_train, y_train, 
                    epochs=2,   #这里为了节约时间，就两轮就差不多了97%正确率了，训练十次差不多0.98左右
                    batch_size=128, 
                    validation_data=(x_test, y_test))
# 评估模型
test_loss, test_acc = model.evaluate(x_test, y_test)
print(&#39;Test accuracy:&#39;, test_acc)

# 预测第10个测试数据的结果
predictions = model.predict(np.array([x_test[9]]))
print(&#34;预测结果：&#34;, np.argmax(predictions))

# 绘制第10个测试数据的图形
plt.imshow(x_test_ori[9], cmap=plt.cm.binary)
plt.show()</code></pre></div>
<p>输出结果</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>Epoch 1/2

  1/469 [..............................] - ETA: 2:17 - loss: 2.2535 - accuracy: 0.1562
 13/469 [..............................] - ETA: 1s - loss: 1.3687 - accuracy: 0.6358  
 25/469 [&gt;.............................] - ETA: 1s - loss: 0.9935 - accuracy: 0.7331
 38/469 [=&gt;............................] - ETA: 1s - loss: 0.8118 - accuracy: 0.7775
 52/469 [==&gt;...........................] - ETA: 1s - loss: 0.7005 - accuracy: 0.8057
 59/469 [==&gt;...........................] - ETA: 1s - loss: 0.6644 - accuracy: 0.8137
 70/469 [===&gt;..........................] - ETA: 1s - loss: 0.6148 - accuracy: 0.8256
 83/469 [====&gt;.........................] - ETA: 1s - loss: 0.5690 - accuracy: 0.8376
 97/469 [=====&gt;........................] - ETA: 1s - loss: 0.5308 - accuracy: 0.8479
111/469 [======&gt;.......................] - ETA: 1s - loss: 0.5008 - accuracy: 0.8562
124/469 [======&gt;.......................] - ETA: 1s - loss: 0.4797 - accuracy: 0.8621
136/469 [=======&gt;......................] - ETA: 1s - loss: 0.4648 - accuracy: 0.8659
145/469 [========&gt;.....................] - ETA: 1s - loss: 0.4548 - accuracy: 0.8683
158/469 [=========&gt;....................] - ETA: 1s - loss: 0.4398 - accuracy: 0.8727
172/469 [==========&gt;...................] - ETA: 1s - loss: 0.4253 - accuracy: 0.8765
185/469 [==========&gt;...................] - ETA: 1s - loss: 0.4145 - accuracy: 0.8802
199/469 [===========&gt;..................] - ETA: 1s - loss: 0.3999 - accuracy: 0.8843
212/469 [============&gt;.................] - ETA: 1s - loss: 0.3899 - accuracy: 0.8872
225/469 [=============&gt;................] - ETA: 1s - loss: 0.3804 - accuracy: 0.8902
238/469 [==============&gt;...............] - ETA: 0s - loss: 0.3700 - accuracy: 0.8933
252/469 [===============&gt;..............] - ETA: 0s - loss: 0.3619 - accuracy: 0.8951
266/469 [================&gt;.............] - ETA: 0s - loss: 0.3537 - accuracy: 0.8979
280/469 [================&gt;.............] - ETA: 0s - loss: 0.3460 - accuracy: 0.9001
291/469 [=================&gt;............] - ETA: 0s - loss: 0.3401 - accuracy: 0.9018
303/469 [==================&gt;...........] - ETA: 0s - loss: 0.3350 - accuracy: 0.9032
316/469 [===================&gt;..........] - ETA: 0s - loss: 0.3298 - accuracy: 0.9046
330/469 [====================&gt;.........] - ETA: 0s - loss: 0.3250 - accuracy: 0.9061
343/469 [====================&gt;.........] - ETA: 0s - loss: 0.3198 - accuracy: 0.9073
357/469 [=====================&gt;........] - ETA: 0s - loss: 0.3132 - accuracy: 0.9090
368/469 [======================&gt;.......] - ETA: 0s - loss: 0.3088 - accuracy: 0.9103
381/469 [=======================&gt;......] - ETA: 0s - loss: 0.3051 - accuracy: 0.9115
395/469 [========================&gt;.....] - ETA: 0s - loss: 0.3017 - accuracy: 0.9125
409/469 [=========================&gt;....] - ETA: 0s - loss: 0.2970 - accuracy: 0.9139
423/469 [==========================&gt;...] - ETA: 0s - loss: 0.2927 - accuracy: 0.9152
437/469 [==========================&gt;...] - ETA: 0s - loss: 0.2889 - accuracy: 0.9163
448/469 [===========================&gt;..] - ETA: 0s - loss: 0.2855 - accuracy: 0.9173
458/469 [============================&gt;.] - ETA: 0s - loss: 0.2827 - accuracy: 0.9181
469/469 [==============================] - 3s 5ms/step - loss: 0.2800 - accuracy: 0.9189 - val_loss: 0.1337 - val_accuracy: 0.9610
Epoch 2/2

  1/469 [..............................] - ETA: 1s - loss: 0.1849 - accuracy: 0.9375
 13/469 [..............................] - ETA: 1s - loss: 0.1216 - accuracy: 0.9597
 25/469 [&gt;.............................] - ETA: 1s - loss: 0.1333 - accuracy: 0.9584
 37/469 [=&gt;............................] - ETA: 1s - loss: 0.1389 - accuracy: 0.9573
 49/469 [==&gt;...........................] - ETA: 1s - loss: 0.1370 - accuracy: 0.9597
 63/469 [===&gt;..........................] - ETA: 1s - loss: 0.1326 - accuracy: 0.9606
 75/469 [===&gt;..........................] - ETA: 1s - loss: 0.1349 - accuracy: 0.9596
 86/469 [====&gt;.........................] - ETA: 1s - loss: 0.1339 - accuracy: 0.9597
 98/469 [=====&gt;........................] - ETA: 1s - loss: 0.1360 - accuracy: 0.9594
110/469 [======&gt;.......................] - ETA: 1s - loss: 0.1385 - accuracy: 0.9587
123/469 [======&gt;.......................] - ETA: 1s - loss: 0.1385 - accuracy: 0.9582
136/469 [=======&gt;......................] - ETA: 1s - loss: 0.1371 - accuracy: 0.9591
147/469 [========&gt;.....................] - ETA: 1s - loss: 0.1369 - accuracy: 0.9593
158/469 [=========&gt;....................] - ETA: 1s - loss: 0.1361 - accuracy: 0.9595
170/469 [=========&gt;....................] - ETA: 1s - loss: 0.1355 - accuracy: 0.9600
182/469 [==========&gt;...................] - ETA: 1s - loss: 0.1360 - accuracy: 0.9601
194/469 [===========&gt;..................] - ETA: 1s - loss: 0.1348 - accuracy: 0.9603
206/469 [============&gt;.................] - ETA: 1s - loss: 0.1330 - accuracy: 0.9610
217/469 [============&gt;.................] - ETA: 1s - loss: 0.1322 - accuracy: 0.9610
228/469 [=============&gt;................] - ETA: 1s - loss: 0.1304 - accuracy: 0.9617
240/469 [==============&gt;...............] - ETA: 1s - loss: 0.1301 - accuracy: 0.9616
252/469 [===============&gt;..............] - ETA: 0s - loss: 0.1290 - accuracy: 0.9618
265/469 [===============&gt;..............] - ETA: 0s - loss: 0.1276 - accuracy: 0.9623
278/469 [================&gt;.............] - ETA: 0s - loss: 0.1264 - accuracy: 0.9625
291/469 [=================&gt;............] - ETA: 0s - loss: 0.1253 - accuracy: 0.9629
304/469 [==================&gt;...........] - ETA: 0s - loss: 0.1246 - accuracy: 0.9632
318/469 [===================&gt;..........] - ETA: 0s - loss: 0.1235 - accuracy: 0.9635
332/469 [====================&gt;.........] - ETA: 0s - loss: 0.1230 - accuracy: 0.9636
345/469 [=====================&gt;........] - ETA: 0s - loss: 0.1220 - accuracy: 0.9641
358/469 [=====================&gt;........] - ETA: 0s - loss: 0.1214 - accuracy: 0.9643
368/469 [======================&gt;.......] - ETA: 0s - loss: 0.1210 - accuracy: 0.9644
380/469 [=======================&gt;......] - ETA: 0s - loss: 0.1209 - accuracy: 0.9643
392/469 [========================&gt;.....] - ETA: 0s - loss: 0.1206 - accuracy: 0.9645
404/469 [========================&gt;.....] - ETA: 0s - loss: 0.1205 - accuracy: 0.9644
415/469 [=========================&gt;....] - ETA: 0s - loss: 0.1206 - accuracy: 0.9643
427/469 [==========================&gt;...] - ETA: 0s - loss: 0.1205 - accuracy: 0.9642
440/469 [===========================&gt;..] - ETA: 0s - loss: 0.1201 - accuracy: 0.9644
452/469 [===========================&gt;..] - ETA: 0s - loss: 0.1201 - accuracy: 0.9643
464/469 [============================&gt;.] - ETA: 0s - loss: 0.1198 - accuracy: 0.9644
469/469 [==============================] - 2s 5ms/step - loss: 0.1198 - accuracy: 0.9644 - val_loss: 0.0944 - val_accuracy: 0.9716

  1/313 [..............................] - ETA: 8s - loss: 0.0785 - accuracy: 0.9688
 19/313 [&gt;.............................] - ETA: 0s - loss: 0.0754 - accuracy: 0.9852
 36/313 [==&gt;...........................] - ETA: 0s - loss: 0.0956 - accuracy: 0.9705
 54/313 [====&gt;.........................] - ETA: 0s - loss: 0.1193 - accuracy: 0.9641
 73/313 [=====&gt;........................] - ETA: 0s - loss: 0.1268 - accuracy: 0.9606
 93/313 [=======&gt;......................] - ETA: 0s - loss: 0.1233 - accuracy: 0.9610
112/313 [=========&gt;....................] - ETA: 0s - loss: 0.1196 - accuracy: 0.9637
130/313 [===========&gt;..................] - ETA: 0s - loss: 0.1234 - accuracy: 0.9618
151/313 [=============&gt;................] - ETA: 0s - loss: 0.1204 - accuracy: 0.9617
171/313 [===============&gt;..............] - ETA: 0s - loss: 0.1137 - accuracy: 0.9642
191/313 [=================&gt;............] - ETA: 0s - loss: 0.1163 - accuracy: 0.9638
210/313 [===================&gt;..........] - ETA: 0s - loss: 0.1119 - accuracy: 0.9658
230/313 [=====================&gt;........] - ETA: 0s - loss: 0.1048 - accuracy: 0.9681
245/313 [======================&gt;.......] - ETA: 0s - loss: 0.1003 - accuracy: 0.9695
263/313 [========================&gt;.....] - ETA: 0s - loss: 0.0979 - accuracy: 0.9699
282/313 [==========================&gt;...] - ETA: 0s - loss: 0.0943 - accuracy: 0.9712
303/313 [============================&gt;.] - ETA: 0s - loss: 0.0911 - accuracy: 0.9723
313/313 [==============================] - 1s 3ms/step - loss: 0.0944 - accuracy: 0.9716
Test accuracy: 0.9715999960899353</code></pre></div>
<h3 id="模型保存和加载">模型保存和加载</h3>
<p>TensorFlow 提供了两种方式来保存和加载模型：
1.使用 tf.train.Checkpoint：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>import tensorflow as tf

# 定义模型
model = tf.keras.models.Sequential([
    tf.keras.layers.Dense(10, activation=&#39;relu&#39;, input_shape=(784,)),
    tf.keras.layers.Dense(10, activation=&#39;softmax&#39;)
])

# 定义优化器和损失函数
model.compile(optimizer=&#39;adam&#39;, loss=&#39;categorical_crossentropy&#39;, metrics=[&#39;accuracy&#39;])

# 训练模型
model.fit(x_train, y_train, epochs=10, validation_data=(x_test, y_test))

# 创建 Checkpoint 对象
checkpoint = tf.train.Checkpoint(model=model)

# 保存模型
checkpoint.save(&#39;./model.ckpt&#39;)

# 加载模型
checkpoint.restore(&#39;./model.ckpt&#39;)</code></pre></div>
<p>2.使用 tf.keras.callbacks.ModelCheckpoint：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>import tensorflow as tf

# 定义模型
model = tf.keras.models.Sequential([
    tf.keras.layers.Dense(10, activation=&#39;relu&#39;, input_shape=(784,)),
    tf.keras.layers.Dense(10, activation=&#39;softmax&#39;)
])

# 定义优化器和损失函数
model.compile(optimizer=&#39;adam&#39;, loss=&#39;categorical_crossentropy&#39;, metrics=[&#39;accuracy&#39;])

# 定义 ModelCheckpoint 回调函数
checkpoint = tf.keras.callbacks.ModelCheckpoint(&#39;./model.h5&#39;, save_best_only=True, save_weights_only=False, monitor=&#39;val_loss&#39;)

# 训练模型
model.fit(x_train, y_train, epochs=10, validation_data=(x_test, y_test), callbacks=[checkpoint])

# 加载模型
model = tf.keras.models.load_model(&#39;./model.h5&#39;)</code></pre></div>
<p>第一种方式使用 tf.train.Checkpoint 对象保存和加载模型，可以保存模型的权重和优化器状态，还支持在训练过程中保存模型和恢复模型。第二种方式使用 tf.keras.callbacks.ModelCheckpoint 回调函数保存模型，可以指定保存最佳模型，同时可以选择保存模型的权重或整个模型。</p>
<h3 id="绘制ui手写数字识别">绘制ui手写数字识别</h3>
<p>首先改写之前的tensorflow代码保存模型</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code># 定义 ModelCheckpoint 回调函数
checkpoint = tf.keras.callbacks.ModelCheckpoint(&#39;./model.h5&#39;, save_best_only=True, save_weights_only=False, monitor=&#39;val_loss&#39;)

# 训练模型
history = model.fit(x_train, y_train, 
                    epochs=8, 
                    batch_size=128, 
                    validation_data=(x_test, y_test),
                    callbacks=[checkpoint]
                    )</code></pre></div>
<p>绘制ui，加载模型并预测显示在ui上</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>import tkinter as tk
from PIL import Image, ImageDraw
import numpy as np;
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.datasets import mnist
# 加载模型并进行数字识别
def recognize_digit():
    # 将画板图像转换成灰度图像，并将其大小调整为 28x28,注意要用convert,因为彩色图像是rgb是三维的，resize只是改变了rg，需要convert转换成灰度的二维
    image_resized = np.array(image.resize((28, 28)).convert(&#39;L&#39;))
    # 反转图像，因为灰度图像是黑底白字，但是我们训练的图片都是白底黑字，所以取反
    image_resized = np.invert(image_resized)
    # plt.imshow(image_resized, cmap=plt.cm.binary)
    # plt.show()
    # 将图像转换为数字数组
    data = image_resized.reshape(1, 784).astype(&#39;float32&#39;) / 255.0

    # 在这里添加您的识别代码
    model = tf.keras.models.load_model(&#39;./model.h5&#39;)
    predictions = model.predict(np.array([data]))
    result_label.configure(text=&#34;识别结果为：&#34; + str(np.argmax(predictions)))

# 清空画板
def clear_canvas():
    draw.rectangle((0, 0, 280, 280), fill=&#34;white&#34;)
    canvas.delete(&#34;all&#34;)

# 创建窗口
window = tk.Tk()
window.title(&#34;手写数字识别&#34;)
window.geometry(&#34;400x400&#34;)

# 创建画布
canvas = tk.Canvas(window, width=280, height=280, bg=&#34;white&#34;)
canvas.grid(row=0, column=0, columnspan=2)

# 创建清空画布按钮
clear_button = tk.Button(window, text=&#34;清空画板&#34;, command=clear_canvas)
clear_button.grid(row=1, column=0)

# 创建识别按钮
recognize_button = tk.Button(window, text=&#34;识别数字&#34;, command=recognize_digit)
recognize_button.grid(row=1, column=1)

# 创建识别结果标签
result_label = tk.Label(window, text=&#34;&#34;)
result_label.grid(row=2, column=0, columnspan=2)

# 创建画板图像
image = Image.new(&#34;RGB&#34;, (280, 280), (255, 255, 255))
draw = ImageDraw.Draw(image)

# 绑定画板事件
def on_mouse_down(event):
    global prev_x, prev_y
    prev_x, prev_y = event.x, event.y

def on_mouse_move(event):
    global prev_x, prev_y
    canvas.create_line(prev_x, prev_y, event.x, event.y, width=20)
    draw.line((prev_x, prev_y, event.x, event.y), fill=&#34;black&#34;, width=20)
    prev_x, prev_y = event.x, event.y

canvas.bind(&#34;&lt;Button-1&gt;&#34;, on_mouse_down)
canvas.bind(&#34;&lt;B1-Motion&gt;&#34;, on_mouse_move)

# 显示窗口
window.mainloop()</code></pre></div>
<p>程序效果
<a href="#R-image-ae126786a865ff53a48488238221f848" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/06024a21cf7d5930e1710762fcc0317f.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ae126786a865ff53a48488238221f848"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/06024a21cf7d5930e1710762fcc0317f.png"></a>
对于手写数字识别，正确率的高低不仅取决于模型的性能，还与数据的质量和多样性有关。在训练模型时，使用的数据集可能与实际应用场景中的数据存在差异，导致模型无法很好地泛化到新的、未知的数据上。</p>
<p>此外，手写数字的识别难度还受到许多因素的影响，如书写的风格、字母大小、笔画粗细、书写方向等等。如果训练集中没有涵盖到这些因素，那么模型就可能无法准确地识别新的手写数字。因此，为了提高手写数字识别的准确率，需要使用更多、更丰富的数据集，并对模型进行调参和优化以提高其泛化能力。</p>
<p>来看下下面这个例子，我们的mlp多层感知器貌似基本无能为力了
<a href="#R-image-2b50de9716aeee5a89740681175a7833" class="lightbox-link"><img alt="在这里插入图片描述" class="lazy lightbox figure-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/6056b3fa880c452dd89963b17f09d221.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2b50de9716aeee5a89740681175a7833"><img alt="在这里插入图片描述" class="lazy lightbox lightbox-image" loading="lazy" src="/docs/images/content/programming/ai/deep_learning/basic/dl_02_mlp.md.images/6056b3fa880c452dd89963b17f09d221.png"></a></p>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> Sep 18, 2025
  </footer>
</article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">
          <a id="R-logo" class="R-default" href="/docs/index.html">
            <div class="logo-title">liaomin416100569博客</div>
          </a>
        </div>
        <search><form action="/docs/search/index.html" method="get">
          <div class="searchbox default-animation">
            <button class="search-detail" type="submit" title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
            <label class="a11y-only" for="R-search-by">Search</label>
            <input data-search-input id="R-search-by" name="search-by" class="search-by" type="search" placeholder="Search...">
            <button class="search-clear" type="button" data-search-clear="" title="Clear search"><i class="fas fa-times" title="Clear search"></i></button>
          </div>
        </form></search>
      </div>
      <div id="R-homelinks" class="default-animation homelinks">
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-homelinks">
          <ul class="space collapsible-menu">
            <li class="" data-nav-id="/docs/index.html"><a class="padding" href="/docs/index.html"><i class="fa-fw fas fa-home"></i> Home</a></li>
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-headercontrols">
          <ul class="">
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div class="R-sidebarmenu R-shortcutmenu-main">
          <ul class="enlarge morespace collapsible-menu">
            <li class="parent " data-nav-id="/docs/programming/index.html"><a class="padding" href="/docs/programming/index.html">编程开发</a><ul id="R-subsections-e3fc01b477dbaf64a8f5013a3dab5c5b" class="collapsible-menu">
            <li class="alwaysopen " data-nav-id="/docs/programming/languages/index.html"><a class="padding" href="/docs/programming/languages/index.html">编程语言</a><ul id="R-subsections-1bbde7fb0c312ba940b425df5a4caf67" class="collapsible-menu"></ul></li>
            <li class="parent alwaysopen " data-nav-id="/docs/programming/ai/index.html"><a class="padding" href="/docs/programming/ai/index.html">人工智能</a><ul id="R-subsections-9d06be7bd8c736c09a65fb0b91b71d0e" class="collapsible-menu">
            <li class="alwaysopen " data-nav-id="/docs/programming/ai/tools_libraries/index.html"><a class="padding" href="/docs/programming/ai/tools_libraries/index.html">工具库</a><ul id="R-subsections-e43804740042696aa314af8cc1e28fa9" class="collapsible-menu"></ul></li>
            <li class="alwaysopen " data-nav-id="/docs/programming/ai/machine_learning/index.html"><a class="padding" href="/docs/programming/ai/machine_learning/index.html">机器学习</a><ul id="R-subsections-d3b98ca0beda96811b8c41829d886d7f" class="collapsible-menu"></ul></li>
            <li class="parent alwaysopen " data-nav-id="/docs/programming/ai/deep_learning/index.html"><a class="padding" href="/docs/programming/ai/deep_learning/index.html">深度学习</a><ul id="R-subsections-8e4f2a2c63b9f66a19e3b2a7c957ccda" class="collapsible-menu">
            <li class="parent alwaysopen " data-nav-id="/docs/programming/ai/deep_learning/basic/index.html"><a class="padding" href="/docs/programming/ai/deep_learning/basic/index.html">深度基础</a><ul id="R-subsections-82d91c326db2e74346572c248dd5a837" class="collapsible-menu">
            <li class="active " data-nav-id="/docs/programming/ai/deep_learning/basic/dl_02_mlp/index.html"><a class="padding" href="/docs/programming/ai/deep_learning/basic/dl_02_mlp/index.html">深度学习02-神经网络(MLP多层感知器)</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/docs/programming/ai/deep_learning/frameworks/index.html"><a class="padding" href="/docs/programming/ai/deep_learning/frameworks/index.html">框架学习</a><ul id="R-subsections-bc6c627c1fa57b86d2660d273634c1d2" class="collapsible-menu"></ul></li>
            <li class="alwaysopen " data-nav-id="/docs/programming/ai/deep_learning/cnn/index.html"><a class="padding" href="/docs/programming/ai/deep_learning/cnn/index.html">卷积神经网络</a><ul id="R-subsections-7bacfefef24ae5de2e950bd8fb081ec1" class="collapsible-menu"></ul></li>
            <li class="alwaysopen " data-nav-id="/docs/programming/ai/deep_learning/rnn/index.html"><a class="padding" href="/docs/programming/ai/deep_learning/rnn/index.html">循环神经网络</a><ul id="R-subsections-addeb8e29ffecb1f809f271ff170a522" class="collapsible-menu"></ul></li>
            <li class="alwaysopen " data-nav-id="/docs/programming/ai/deep_learning/gans/index.html"><a class="padding" href="/docs/programming/ai/deep_learning/gans/index.html">生成对抗网络</a><ul id="R-subsections-2787239befb1b0643d0f03fc48340180" class="collapsible-menu"></ul></li></ul></li>
            <li class="alwaysopen " data-nav-id="/docs/programming/ai/computer_vision/index.html"><a class="padding" href="/docs/programming/ai/computer_vision/index.html">计算机视觉</a><ul id="R-subsections-ee78ef5588610a65894e6d07832cb0b2" class="collapsible-menu"></ul></li></ul></li>
            <li class="alwaysopen " data-nav-id="/docs/programming/plugins/index.html"><a class="padding" href="/docs/programming/plugins/index.html">插件开发</a><ul id="R-subsections-de66f54cff99288ca68bfcb5bb0439ae" class="collapsible-menu"></ul></li></ul></li>
            <li class="" data-nav-id="/docs/devops/index.html"><a class="padding" href="/docs/devops/index.html">运维一体化</a><ul id="R-subsections-389d4feb4920b919bcbc0b1e9947dace" class="collapsible-menu"></ul></li>
            <li class="" data-nav-id="/docs/security/index.html"><a class="padding" href="/docs/security/index.html">安全攻防</a><ul id="R-subsections-66815ecaaecfc1c209e5637d03b258b2" class="collapsible-menu"></ul></li>
          </ul>
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-shortcuts">
          <ul class="space collapsible-menu">
          </ul>
        </div>
        <div id="R-footer-margin"></div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-footercontrols">
          <ul class="">
          </ul>
        </div>
<div id="R-footer"><p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p></div>
      </div>
    </aside>
    <script src="/docs/js/clipboard/clipboard.min.js?1758355652" defer></script>
    <script src="/docs/js/perfect-scrollbar/perfect-scrollbar.min.js?1758355652" defer></script>
    <script src="/docs/js/theme.min.js?1758355652" defer></script>
  </body>
</html>
